
# internet

个人理解：每个计算机终端，插上网线，组成的一种类型网状型的，一个网络，理论上没人控制能完全控制它。

end\-to\-end ,terminal\-to\-terminal，再具体点，就是people\-to\-people。刚刚组建的时候，自然人数较少，随便插几个根即可，随着加入的人越来越多，internet的内部结构就变的超级复杂，各种设备应用而生。才会有各种大的集团公司来建设基础设施。才会给人感觉是个超级大的鬼东西。

# 诞生的目的

套用我高中教材上的话吧，1资源共享2即时通信

实际上，从我13\-14（1999年左右）岁开始接触网络，到高中开始学计算机网络的枯燥的课本，再到现在，还是觉得挺神奇的，其最初的诞生的目的也仅仅是共享和通信，到现在已经能够演变成生活的一部分，真的是好神奇！！！

计算机是使用电的，说到底就是0和1，由1999年左右的时候，还是电话线上网，来个电话，网就断到了，到后来的各种设置，什么：同轴电缆、双绞线、宽带、光纤，WIFI、再到现在的手机 5G，网络真的跟我最初那会比起来进步太多太多了，也难怪，现在人们离不开这鬼东西。

分类：

公共：互联网就是最好的公共
专用 ：一个公司 铁路网络 等等

# 历史

1969 年APRAnet 项目成立，仅连接4台电脑，1974有了分组协议，其也包含了TCP/IP

# 电路交换

专线通话：AB通话时，有一根线直接连通AB两端，这个最理想。
> 但，这不太现实，人数多了，这得多少根线连接？



若干用户统一连接到一个物理硬件上：电话交换机

## 电话交换机

1. 用户与用户之间先建立连接，交换机来分配 通信 资源
2. 挂了电话后，交换机要释放该资源

交换机也不太可能只有一台，全世界用户都连接它。那么，交换机与交换机也可以互联
比如：中国有一部交换机X。 A区域有一个交换机Y，那么用户1就先连接Y，Y再连接X

优点：类似专线，时延小、数据是顺序传输的，也不存在冲突
缺点：只有2个人使用，控制也比较简单。得建立连接。长时间占用线路，

# 计算机数据交换

电路交换机能不能给互联网传输数据？
不能，因为：电话的状态是可控的，一个人主动打，另一个主动接。挂了即断了。而互联网的数据太碎片化、突破发式的

分组交换 packate switch：不需要建立连接

发送者：构造分组，发送分组.给数据加上各种头信息

路由器：存储/转发，接收分组后的数据，短暂存储，然后转发到外网

接收者：拆包，去头，还原最终的：数据

优点：线路利用率高、容错强

缺点：延迟略高、要有存储功能、传输的数据过多，得有各种头、数据传输顺序

# 各种设备

集线器、路由器、猫、光猫、网桥、交换机、三层交换机

## 集线器

1. 几个人可以快速组建一个局域网，只要大家把每个人的机器连到上面就行
2. 有少量的容错能力，比如：某台机器出错不停的发送错误帧，集线器迅速断开些设置
    缺点：
3. 还是总线模式，人一多，光CSMA/CD就累死
4. 发送一条消息，还是所有人都能收到，然后所有人再各自筛选丢弃/接收

## 交换机/网桥

接入方式和集线器差不多，所有主机将网线插进去即可。

优点

1. 内部维护了一个映射表，MAC地址\-\>接口号
2. 某个人发一条数据，在内部维护表里找到对应接口号，直接发给它，不是总线广播模式了

映射表的由来过程：

A发送到B，首先将A记录下，然后广播给所有人，肯定只有一个人收到，这个人收到后，要响应消息，再将响应数据发送给A，这个时候，记录下B的记录。 即此时 A B 的MAC和接口号 即记录完成了。

交换机是工作于数据链路层，主要操作MAC和接口号的

泛洪：广播

丢弃：A B 连接在一个集线器上，集线器又连接交换机，A发消息给B，消息在集线器内肯定是广播的，此时B肯定是立刻能收到，但是交换机也会 收到该消息，发现是接口1发消息给接口1，这是错误的，直接丢弃

## 交换机 STP：spanning tree protocol

正常一个网络3个交换机单线连接，B连A，C连A，但如果其中一个条线坏了，比如 B连A的线断了，那么B就成LAN了，如果在B和C之间加一条线，就算AB之间的线坏了，B还可以访问C，通过C再访问A。

上面这个更像是容灾，本是好事，但会遇到无限循环的总是，比如：广播风暴，各种重复消息在内部流通。交换表振荡/漂移

这个时候，使用STP协议，即：如果是广播消息，在某个端口就卡住，但构建这个过程就是spanning tree。核心是：将产生的环路转换成一棵树的结构，即将交换机标上ID号，找一个ROOT，再依次根据ID大小构建一个树

## 路由器/网关

交换机是根据自己的物理端口\(接入网线\)工作的，它基本上没有IP的概念的
而路由器才是真正处理IP的容器。
好像早期的文档都叫网关，后期都叫路由器了
IP寻址
对包的检查
防止广播网暴

## 各种线路

粗/细同轴电缆、水晶头、双绞线

1. 粗/细同轴电缆：具说已成为过去式，早期觉得这种无缘的电费线更可靠，有缘器件不可靠。会大量使用机械接头。
2. 水晶头：塑料头，包装双绞线插头线。
3. 双绞线：网线。

总结：有缘的双绞线 配上集线器，更稳定可靠，且还便宜

## MAC，Media Access Control

每个网卡上的ID号，由IEEE\-802.3以太网标准定义。官方叫法是：网络接口标识

6个字节，前3个字节：组织机构代码，给厂商的，后3个是厂商随意分配的

作用于网络链路层

## IP：internet protocol

网线上的ID号，像：地域、子网等
作用于网络层
IP协议头占20个固定字节\+40个浮动字节
数据帧分片也在这层
TTL的值，就在这层设置，除了能计算路由次数外，还能防止路由死循环

协议：ICMP TCP UDP IGMP IPv6 OSPF

详细的参考另一个文章

## OSI体系

OSI（Open System Interconnection）：

> 最早的网络模式

|层        |协议                                    |
|----------|----------------------------------------|
|应用层    |telnet、ftp、http、dns、smtp、pop3      |
|表示层    |数据格式化，代码转换，数据加密，没有协议|
|会话层    |解除或建立与别的接点的联系，没有协议    |
|传输层：  |tcp、udp                                |
|网络层    |IP，ICMP，OSPF，BGP，IGMP ，ARP，RARP   |
|数据链路层|SLIP，CSLIP，PPP，MTU（网卡）           |
|物理层    |ISO2110，IEEE802，IEEE802.2             |

> 数据链路：ETH头\+IP头\+TCP头\+HTTP协议内容体\+ETH尾\(FCS校验\)
> 物理层：可能添加特殊比物流（帧开始定界符、前同步码）\+0101010101010101010

## TCP/IP

参数另一个文章

## 仿真模拟调度工具

cisco packet tracer，挺神奇一软件，像是画流程图一样，可以拖拽各种实体，然后，还能让各实体走网络通信，通信还可以打断点，并能每个步骤的通信，都能出请求包的结构，TMD，我上学的时候咋没这个东西...

为什么将网络协议分出N层出来？

答：将网络体系结构的各个功能，抽离、分拆，每层负责各自的模块，更好的调错与研究。同时，将较大的问题转换到较小的局部。

## PDU（Protocol Data Unit）

应用层：应用报文 message
传输层：segment datagram
网络层：IP数据报或分组
链路层：帧
物理层：比特流

## CSMA/CD

carrier sense multiple access with collision detection

载波监听多点接入/碰撞检测

MA多点接入：多个主机连接在一条总线上，竞争使用总线

CS载监听：发送数据前先检测总线（先听后说）。若总线空闲，则立刻发送。若线总忙，则持续检测总线直到空闲

CD碰撞检测：这发边检测碰撞（边说边听），若检测到碰撞，则立刻停止发送，退避一段时间后重新发送。

PS：挺复杂的一个东西，但很神奇

## VLAN

广播风暴，之前以为没多少，但实际上广播消息还是挺多的：ARP、RIP、DHCP等
避免的方式就是：在一个交换机内处理这些消息，而不广播到所有的交换机上

## 网卡

物理硬件，会有一个ID叫MAC地址，接收OS封装后的数据，再封装一下，发送到网线上OR从网上接收数据包，拆包~发给主机
这个硬件，也有缓存模块
这里也会做些简单的判断，如：MAC地址不属性该网卡、CRC数据校验等

## LO Loop back address

本地环回，类似 localhost 127.0.0.1 都是走本地请求

即：类似这种主场它不会走网卡，有点像是IPC

## ICMP internet control message protocol

作用于IP层，主要是保证IP层的数据传输的一些容错消息。

主机或路由器发送 差错报文 和 询问报文

如：

1. 路由器TTL=0了，即发一个ICMP 差错报文
2. A发送UDP数据给B，B接收了，发现端口号错误了，发一个ICMP 差错报文

询问报文

PING packet internet groper：查看两个主机的RTT

traceroue/tracert:检测路由次数

# APR

ip 转 mac

# TCP flow\-control

让发送方的发送速率不要太快，这样接收方有足够的时间接收

方法：由接收方控制发送数据的速率

1. 停止\-等待 stop\-wait
2. 滑动窗口

停止等待：每发一帧，都得等待接收方发一条ACK消息，效率太低

滑动窗口:双方维护一个窗口大小，同一时间，只能传输窗口大小的数据

# RTO\- Retransmission TimeOut

重传时间，实际就是一个定时器，如果在一个定时器时间周期内，未收到响应，即触发该定时器，并执行一个\<重传发包\>操作
这个定时器时间设置就比较烦，最简单的方式，至少要略大于RTT。但麻烦的是RTT的计算又是极其复杂的一个过程...

# ARQ \- automatic repeat reQuest

自动重传请求，这个就是保证：可靠性

# GBN \- go back N

后退N帧协议

发送方，可一次发送N条数据帧，但是接收方只能有一帧确认机制，如：

1. A 发送了 帧012345 B接收到012345 ，OK，B返回ACK=5
2. A 发送了 帧012345 B接收的则是015234 ，B返回的ACK=1，即：01是正常的，因为是有序的，5234是错误序号的，那，即A就得重新发送5234

与SW方法比起来，不同点是：发送方可以一次多发几条数据，感觉并没有快太多

# SR select Retransmission

选择重传

发送方，可一次发送N条数据帧，接收方也同样可可接收N帧
接收方，会在一个RTO内等待 窗口内的所有数据帧到齐后返回整体ACK，即使序号不一样，也无所谓，只要在窗口期整体的所有数据帧都能正确收到即可
而，如果发现某些帧有错误码的，会立刻返回NACK，这样发送方接收后，就单独重发这条数据帧，而不用整体重发
对比上面两种方，选择重传真的做到了，发送方可以N条，接收方N条，并且重发机制也能做到具体到某帧重发，整体效率比较好

# RWND receive window

接收者给发送者进行限流，即：如 rwnd = 100 ，发送者下次最多就能发送100个字节

rwnd= 0，这个是接收者告诉发送者，不能再发送消息了，此时发送者不能再发送任何消息了，发送者注册一个RTO

CWND congestion window

SWND send window

# RTT 测量

很复杂的东西，正常来说，每次通信的RTT ，可能都不太一样。另外这里还牵扯到重传，是以第一次成功为准 ，还是以重传的周期为准 。

# RTT\_S 计算公式

带权算法：

RTT\_S1 = RTT1

RTT\_S = \(1\-a\) X 旧的RTT\_S \+ a x 新的RTT\_S

a = 0.125

# RTT\_D 公式

RTT\_D1 = RTT1 / 2

新的RTT\_D = \(1 \- B\) X 旧的RTT\_D \+ B X | RTT\_S \- 新的RTT样本 |

B = 0.25

# RTO 公式

RTO = RTT\_S \+ 4 X RTT\_D

# mtu : maxinum transmission unit

以太网帧头部占14个字节，和帧尾占4个字节，共计18个字节，最后 报文就是1518\-18=1500

# mss maxinum segment size

TCP最大可传输报文段，跟MTU有点像，区别是，仅限：TCP协议

IP协议，头部20个字节，TCP头20个字节 1500 \-40 = 1460

同上，通常TCP头还多一个12字节的unixstamp,1460 \- 12 = 1448

# 数据分片

这个就是作用于IP层的~这层是将IP数据发给数据链路层封装成 数据帧，但前提是不能大于1500个字节，一但大于就得将数据分片了，分片除了发送的时候，首部的计算麻烦，接收方，也得要计算，比如：A B C 数据帧都到了接收方，接收方得 排序 A B C 然后，组成成一个完整的数据发给TCP层

# 数据分段

TCP层，MSS分段，既然IP层也会做分片，为什么TCP还得再搞出来个分段呢？因为IP层是非可靠传输，被分成若干片的数据，如果其中一片数据丢失，TCP并不知道是哪片数据丢了，故~会导致整片数据重新发送，加大了网络开销，如果在TCP层，提前避免分片，就可以提高效率，即：TCP分段产生。

# 拥塞控制

整个算法机制 ，由下面4种算法配置完成：

1. 慢开始 slow\-start
2. 拥塞避免 congestion\-avoidance
3. 快重传 fast retransmit
4. 快恢复 fase recovery

假设A 请求 B

A维护一个CWND的值，此值为动态变化。只要没有出现拥塞，该值会递增

如何定义发生拥塞：没有按时收到ACK 或 发生了RTO

初始情况下，SWND=CWND

同时维护一个SSTHRESH值

当cwnd \< SSTHRESH 使用慢开始算法

当cwnd \> SSTHRESH ，停止慢开始算法，改用拥塞避免算法

当cwnd == SSTHRESH，慢开始或拥塞避免 都可以

流程梳理：

刚开始，都是慢开始算法，递增比较快，当到达SSTHRESH阀值后，启动拥塞避免算法，递增步长变为1，也就是发送的帧数变的慢很多。虽然慢，但依然还是在递增，当发送方已到达最大阀后（假设当前发送了20个帧，结果只接收了18个ACK，迟迟收不到那两个，且触发了RTO，即认识可能到达了最大阀值），将当前SSTHRESH缩小一半，同时CWND=1，重启慢开始算法。

总结下：每个连接，开始的时候，都是正常较快流控，但触发了某个阀值后，开始限流，用较慢的方式让该连接传输数据，但当该连接依然有大量的数据发送，且到了最大阀值后，直接清0，重新开始，同时把慢阀值降低~

这里可能有个问题：拥塞避免算法，到达最大阀值的计算方式，即：一但触发了RTO即认为成立，很可能是误判。所以新的TCP版本加入了 快重传 快恢复 算法。

简单说就是：多发几个帧，接收方也快速响应，并做预判。一但这种丢失。这样就会触发多条 重发/NACK 等情况，不可能都处理，以3做为一个阀值。如：发送方收到3条重复确认，但并不开启慢开始算法，而执行快速恢复算法，最后：SSTHRESH\+3

# TCP Tahoe 版本

慢开始\+拥塞避免 时期的算法，解决拥塞

# TCP reno 版本

慢开始 拥塞避免 快重传 快恢复

# TCP 3次连接 解决的问题

1. 连接的过程中，可以双方协定一些参数，如：CWND、窗口扩大选项、时间戳选项等服务质量参数
2. 确定双方是否都处于在线状态

# TIME WAIT

C端关闭后等待时长，防止S端发送的close丢失，而C端迟迟收不到，造成S端不停的重值

# MSL maximum segment lifetime

close time wait 最大报文生命周期，默认是2分钟

# VPN Virtual private network

虚拟私有网络，A分公司内部组成的一个网络，B分公司也是一个内部组成的一个网络，现在A如果想访问B？就得通过两个路由器中转，而两个路由器又是通过internet互联的。通信的数据会被加密。

# NAT network address translation

网络地址转换

一个路由器如果有NAT功能，即该路由器内置了一个NAT模块，即，该路由器有一个IP地址

# NATP network address and port translation

网络地址与端口号转换

# 待处理

C端插值补偿

R\-UDP

冗余 关键帧

