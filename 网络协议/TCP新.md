# 概览

先看一下：OSI TCP/IP4 对比

![TCP-OSI.png](image/TCP-OSI.png)

> OSI参考模型的过于庞大、复杂招致了许多批评。

数据的传输的过程：都是逐层向下增加报文头

![204912498d406e38ab40704c80ec2d1d.jpg](image/204912498d406e38ab40704c80ec2d1d.jpg)

> 图上，用户发送一次数据的大概过程。经过每层，都需要在原数据前面加上本层的信息。

TCP/IP：实际是上一组协议，大体上分为：TCP协议\+IP协议组成

TCP协议负责的是本机数据的处理：数据拆分包、传输的稳定性、端口映射进程等，而网络的路由，对端机器的寻找，这些交给IP层来做，最后加上物理层传输二进制数据，基本上就满足了网络请求

# TCP

transmission control protocol ，传输控制协议

TCP\-数据格式：

![TCP.png](image/TCP.png)

1. 源端口号\(16位\)

> 从上面看到端口号：2^16=65535个

1. 目录端口号\(16位\)
2. 初始序号ISN\-顺序号\(32位\)
3. 确认序号\(32位\)
4. 头部长度/数据偏移\(4位\)
5. 保留
6. 标志位，6位
    1. URG：紧急指针
    2. ACK\(Acknowledgement\):确认序号有效
    3. PSH：接收方应该尽快将这个报文段交给应用层
    4. RST：重新连接SYN：同步序号用来发起一个连接
    5. SYN表示SYN报文（在建立TCP连接的时候使用）
    6. FIN：发端完成任务
7. 滑动窗口大小\(16位\)
8. 校验和\(16位\)
9. 紧急指针\(16位\)
10. 可选项\(8的整数倍\)
11. 数据

## 分析

相比IP协议，TCP可要复杂不少

1. 连接机制：建立连接，断开连接

> 确认号、顺序号、连接标志

1. 滑动窗口机制\(保证可靠传输，并且有顺序性\)

> 另外我们看到，TCP里没有IP地址信息，TCP并不是关心网络层的事情，更关心:数据的传输，端口映射进程的相关事情

# TCP创建连接

![TCP-CONN.png](image/TCP-CONN.png)

#### 基础术语

顺序号\(sn\):32位\-正整数\(0~4294967294\)

确认号\(ack\):接收方，把发送方发来的顺序号\+1

x：任意一个自然整数，由客户端系统生成，也是sn号

y：任意一个自然整数，由服务器系统生成，也是sn号

客户端状态：

1. SYN\_SENT：请求连接状态
2. ESTABLISHED：连接成功
3. CLOSED：连接关闭

服务端状态：

1. LISTENING：监听状态
2. SYN\-RCVD状态:收到和发送一个连接请求后等待对方对连接请求的确认
3. ESTABLISHED状态:连接成功

## 三次握手

第一次握手：客户端发送包\(头\), flags 字段中的 SYN=1 ，随机生成一个数:x，sn=x,到服务器，并进入SYN\_SEND状态，等待服务器确认

第二次握手：服务器收到包\(头\),，判断 SYN=1，是要建立连接，于是，返回包\(头\)：随机生成一个数y, SYN=1,ACK=1,sn=y,ack=X\+1，此时服务器进入SYN\_RECV状态

第三次握手：收到服务器的包\(头\)：判断 SYN=1，ACK=1，这是确认连接，然后，向服务器发送确认包头：ACK=1，sn=x\+1、ack=y\+1\)，客户端进入 ESTABLISHED 状态

服务端接收到客户端的确认信息后，进入 ESTABLISHED 状态 完成三次握手。

> 看着是3次握手，实际两端要处理逻辑其实共计是4次，3次更多的是指网络请求走了3次而已

整个过程：只需要处理头信息即可，包里并没有任何数据。两端各生成一个随机数，以确保是安全的连接

发送数据

当连接那上成功后就要发送数据了，正常一个数据段，可能很长，也可能很短。拿比较长的来说，数据先会被写到缓冲区，然后打包成TCP报文段，直到最后一段数据进来，再次进行打包，然后加此报文的flags中的psh置成1，ack设置成1，统一发送出去。

接收方，会把报文，依次放入到 读，缓冲区。如果全部收全且发现有psh标识,则立刻通知应用层进程，来拿数据。再返回给发送方一个ACK~之后。

这里，如果保证发送方的数据，接收方都能够接全。就牵扯到 窗口滑动机制了。

# TCP关闭连接

> 结合上面的图

4次握手：

1. A发了关闭请求 \(FIN=1、seq=x、ack=z\)，状态变成：fin\_wait\_1状态
2. B接收到，判断标识位FIN=1\(seq=z、ack=x\+1\)关闭了其中一个通路，然后给A发起一个ACK
3. A接收ACK确认此条线路被关闭，状态切换到 fin\_wait\_2状态.B再发出关闭请求FIN，进入last\_ack状态
4. A收到关闭ADK请求，然后再给A发送一个ACK，进入time\_wait 状态

> A经过2个MSL后，自动关闭此条连接

最后，B接收到，判断标识位FIN=1\(seq=x、ack=y\)再关闭一条通道，到此全关闭了

MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。

# TCP连接的漏洞

## 半连接

当服务端接收到C端的连接请求后，会发包，然后进入 SYN\-RCVD 状态，而如果迟迟等不到C端的第三次握手请求，就会产生一堆的半连接

未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN 包，并向客户发出确认，正在等待客户的确认包。

这些条目所标识的连接在服务器处于 Syn\_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

## time\-wait

在高并发情且短连接情况下，如：HTTP协议，服务端大多会主动断开TCP连接，那么，在timewait状态下，要等待2msl的时间，这会造成socket数量不够用

# TCP窗口滑动

当进程，将要发送的数据，发送到缓冲区后~该区域就把所有数据打上4种标识

1、已发送并确认过的数据

2、已发送未确认过的数据

3、接下来，即将要发送的数据

4、未发送的数据

实际上，2、3步骤，会被一个 虚拟的 窗口覆盖上~当2步数据经过确认后，窗口自动向右滑动。

# UDP

user data protocol 用户数据报协议不可靠的、无连接的数据报服务，实际更深入的了解是：没有进行3次握手，也就是没有校验的过程，直接将报文头\+数据，发送给目的主机。![a970d7b1a3a591f2dfcb35413cb914ae.jpg](image/a970d7b1a3a591f2dfcb35413cb914ae.jpg)

通过以上，实际上个人的理解是：IP处理的是主机到主机的通信，而TCP处理的是一台机器上端口到端口的通信，也就是进程之间的通信。

最初，为了实现几台，或者一栋楼里的机器互联，就产生了IP路由器，也就是网关

# MSS

Maximum Segment Size：最大报文段，是TCP协议的一个选项。

MSS选项用于在TCP建立连接时，收发双方协商一个TCP报文段所能承载的最大数据长度。MSS选项只在初始化连接请求\(SYN=1\)的报文段中使用。选择合适的MSS很重要。如果MSS小了，网络利用率低。如果MSS大了，由于在网络层需要分片，也会影响网络性能。一般MSS的长度为MTU\(1500\)\-IP首部\(20\)\-TCP首部\(20\)=1460字节。

5元组

一个新连接，在服务器端，是一个SOCK，FD。也就是是一个连接文件，该文件的标识：源IP\+源端口\+TCP/UDP\+目标IP\+目标端口

# keepalive

keepalive:保活机制。

拿linux socket来说，虽然各种书籍文档都说网络要建立连接，而这个'连接'并不是真实有个链接，道理很简单：真要是有根物理的网张创建连接，那一个服务器得有多少条这样的网线？不现实。

实际就是：双方做个验证，留个TOKEN之类的，再由OS接管，弄2个socket FD，而已。

那么，这条虚拟的连接，如果双方不消息，双方又如何知道对方是否还在线呢？

FIN这种关闭是有很多问题的，如：

1. 对方进程挂了，OS直接无视，根本没来得及发FIN，
2. 某一方网络出了问题，也发不出去FIN
3. 某方CPU计算量非常大，而当前进程拿不到CPU资源，只能等待。
4. 丢包
    ....

> 发不出去FIN的情况其实很多的......

headerbeat：心跳机制，对于上面说的两端如何知道对方在线？其实也没有太好的办法，异常太多，于是 就有了一种折中的方案：两端定时发送一个空包，一但超过一定时间 未接收到，就证明对方可能网络出现了问题，就可以主动关闭了

TCP\-keepalive

> cat /proc/sys/net/ipv4/

3个重要参数：:

tcp\_keepalive\_time：默认 7200 秒

tcp\_keepalive\_probes：默认 9 次

tcp\_keepalive\_intvl：默认 75 秒

> 7200秒后，对方没有响应，就发送一个探测包，之后每75秒后再发送一个包，发送9次没响应，关闭连接

应用层\-heartbeat

虽然TCP已有了KEEPALIVE，但问题是，以TCP层，只是能确定，连接是否存在 ，并不能确认该连接是否还能传输数据，比如：对方主机假死，连接在，不能接收数据了

# 待解决

mmap内存映射
LINUX的几个指令查看连接状态：
tcpdump
traceroute
ping
netstat
route
PING（Packet InterNet Groper）中文名为因特网包探索器，是用来查看网络上另一个主机系统的网络连接是否正常的一个工具。向XX机器发送ICMP包
ICMP
Internet Control Message Protocol ，网际控制报文协议，错误侦测与回报机制
