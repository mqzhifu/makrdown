
# 概览
单进程，单线程，异步IO

C++有两种分配内容方式，预先分配，动态分配，预先分配会造成浪费，而动态分配运行速度快，MEM采用的是预先分配

slab page chunk

salb包含若干page,PAGE包含若干chunk

slab的大小及数量是根据配置生效，PAGE则固定1MB，如：一个SLAB是100M，那么它下面就有100个PAGE

而chunk才是最终存数据的地方

# LRU
Least Recently Used 近期最少使用算法，当内存满后，新进来要存储的数据，会找到不被使用却占用内存的数据，覆盖

而当一个SALB是1M，也就是有一个PAGE，然后一个下面的chunk是由数据大小决定的，假设是80B，那么1024/80=12.8个chunk。但如果有2M，那么SALB中的chunk的大小是80*1.25，这个1.25系数是由启动的时候配置

再说，如果新set一个值，这个值应该存到哪个slab下面，还是由该值的大小决定的，如果我这次存的是一个79B的数据，就会放到如上的PAGE中，那么问题来了，slab，如果过小的话，这一块的数据就容易满，而容易满，就会被LRU 覆盖掉

一致性哈希

假设有A B C D E 五台机器，KEY：1 2 3 4 5 ， 机器名 key mod 5 = 落到 哪台机器，如果我再新加一台F，该算法失效。

算法改进：

给每台机器设置一个 整数范围，比较大的

A：0~100000
B：0~200000
C：0~300000
D：0~400000
E：0~500000

计算一个KEY落到哪台机器的算法：先把KEY用CRC32(hash函数)，计算出来一个数字值，如果在500000以内，挑一个距离 最近 的机器，如果大于500000，就跟500000取个余数

这个时候增加一台机器F，因为最大值已经设定为500000，所以取值只能 在500000之内，看一下这5台机器哪负载比较高，假如A比较高，那就给F的取值范围为：150000~199999

F：150000~199999

A：100000~149999 改变

新算法：当一个KEY hash = 150001，原先之前肯定是落 在服务器A，这个时候加个判断如果<150000去A，如果大于则去F服务器。

再看一下如果某一台服务器挂机了，假设E挂机了

现在有个KEY为450000，按正常来说应该落 到E上面，但E，PING不通，于是循环，找一个距离它最近的服务器，E后面没有服务器了，那就循环，A是最近的。于是落 到A上。

当前线程数

一、缓存命中率 = get_hits(总命中次数)/cmd_get * 100%

二、get_misses的数字加上get_hits应该等于cmd_get

三、total_items == cmd_set == get_misses，当可用最大内存用光时，memcached就会删掉一些内容，等式就会不成立

memcached/scripts/memcached-tool