# 概览

单进程，单线程，异步 IO

C++有两种分配内容方式，预先分配，动态分配，预先分配会造成浪费，而动态分配运行速度快，MEM 采用的是预先分配

slab page chunk

salb 包含若干 page,PAGE 包含若干 chunk

slab 的大小及数量是根据配置生效，PAGE 则固定 1MB，如：一个 SLAB 是 100M，那么它下面就有 100 个 PAGE

而 chunk 才是最终存数据的地方

# LRU

Least Recently Used 近期最少使用算法，当内存满后，新进来要存储的数据，会找到不被使用却占用内存的数据，覆盖

而当一个 SALB 是 1M，也就是有一个 PAGE，然后一个下面的 chunk 是由数据大小决定的，假设是 80B，那么 1024/80=12.8 个 chunk。但如果有 2M，那么 SALB 中的 chunk 的大小是 80\*1.25，这个 1.25 系数是由启动的时候配置

再说，如果新 set 一个值，这个值应该存到哪个 slab 下面，还是由该值的大小决定的，如果我这次存的是一个 79B 的数据，就会放到如上的 PAGE 中，那么问题来了，slab，如果过小的话，这一块的数据就容易满，而容易满，就会被 LRU 覆盖掉

一致性哈希

假设有 A B C D E 五台机器，KEY：1 2 3 4 5 ， 机器名 key mod 5 = 落到 哪台机器，如果我再新加一台 F，该算法失效。

算法改进：

给每台机器设置一个 整数范围，比较大的

A：0~100000
B：0~200000
C：0~300000
D：0~400000
E：0~500000

计算一个 KEY 落到哪台机器的算法：先把 KEY 用 CRC32(hash 函数)，计算出来一个数字值，如果在 500000 以内，挑一个距离 最近 的机器，如果大于 500000，就跟 500000 取个余数

这个时候增加一台机器 F，因为最大值已经设定为 500000，所以取值只能 在 500000 之内，看一下这 5 台机器哪负载比较高，假如 A 比较高，那就给 F 的取值范围为：150000~199999

F：150000~199999

A：100000~149999 改变

新算法：当一个 KEY hash = 150001，原先之前肯定是落 在服务器 A，这个时候加个判断如果<150000 去 A，如果大于则去 F 服务器。

再看一下如果某一台服务器挂机了，假设 E 挂机了

现在有个 KEY 为 450000，按正常来说应该落 到 E 上面，但 E，PING 不通，于是循环，找一个距离它最近的服务器，E 后面没有服务器了，那就循环，A 是最近的。于是落 到 A 上。

当前线程数

一、缓存命中率 = get_hits(总命中次数)/cmd_get \* 100%

二、get_misses 的数字加上 get_hits 应该等于 cmd_get

三、total_items == cmd_set == get_misses，当可用最大内存用光时，memcached 就会删掉一些内容，等式就会不成立

memcached/scripts/memcached-tool
