# 概览

缓存解决的核心问题是：原本频繁访问DB，改成访问缓存。增加构架的稳定性

DB 里存储的全面的/较大的数据，开发者每次访问DB，DB需要计算过滤，最终只有几条记录是满足要求的，然后返回给开发者。如果把这几条记录存进缓存中，那么DB的压力就会非常非常小。

缺点：

1. 多加了一层\(缓存层\)，要整体维护这一层
    1. 软件的安装/重启
    2. 配置文件调车与优化
    3. 故障排除等等
    4. 报警
    5. 数据统计
    6. 容灾处理
2. 需要多加服务器或吃掉原服务器一部分性能
3. 请求链路中也多加了一层，
    1. 会增加一次请求的一些时间
    2. 增加了一定的开发复杂度
    3. 开发在：查错/调试略麻烦

# 图
```mermaid

graph LR

A[中心] --> 开源软件
开源软件 --> memcache
开源软件 --> redis
开源软件 --> squid
A[中心] --> 主要问题
主要问题 --> 雪崩
主要问题 --> 击穿
主要问题 --> 穿透

雪崩-->集群
雪崩-->key添加随时失效时间
击穿-->竞争锁
击穿-->不失效的key
穿透-->布隆过滤器
穿透-->设置空对象

A[中心] --> 监控
监控--> 命中率

```

# 一些基础问题

## 雪崩

某一时间，缓存挂了，导致请求直接打到数据库上，DB可能挂了。运维重启DB，依然有大量请求直接打到DB中，DB继续崩

出现此问题的主要原因：

1. 缓存服务挂了

> 缓存做集群

1. 缓存失效时间过于集中

> 所有KEY的失效时间自动加一个随机值

## 击穿

同雪崩类似，只是它是某一个KEY，或某几个KEY。像：一些热点KEY，访问较大的，它瞬间失效还没来得及重新缓存，大量的请求直接到DB，也可能把DB带挂了。

1. 当key失效，先去竞争拿个锁，拿到的才有权去直接访问DB
2. 直接不失效，再有一个程序去维护此key值的修改

## 穿透

请求要访问的DB数据，本就不存在，先查 缓存为空，缓存再请求DB依然为空。此时，如果黑客大量伪造类似请求，也就等于直接跳过了缓存，直接访问DB了。

> 注：这里做下与击穿的区别，击穿是本就应该有这样的一个key，可能当前失效不存在 ，再请求DB重写缓存。而穿透是压根就不存在这个key，再请求DB也一样不存在缓存KEY

1. 布隆过滤器判断KEY是否存在
2. 缓存一个特定的'空对象'，用于标识为：空

## 总结

对于记住这3个关键词：这里做个小技巧

1. 雪崩，就是有大指的请求到来
2. 击穿，重点在于这个 '击' 字，得先打击再穿透
3. 穿透，根本就是无视缓存的存在，直接透过去了\(缓存\)

以上的3个问题，其主要都是解决，缓存失效，请求直接打到DB上。

# 冷热数据

冷数据：访问次数不高的数据。

热数据：经常访问的数据。

> 二八定律：一个 redis 里缓存的数据，可能20%访问的频率是最高的，剩余的80%可能访问率很低

具说 redis 在2.0 以前有个 VM机制 ，就是虚拟内存，不常访问的放到磁盘上。不过缺点就是可能会偶尔导致redis重启。2.4 之后就放弃了。

自实现 代理层，所有的IO 均先到代理层这里，如果数据过大,value 就不写redis ,只做个标记，实际的数据存储到 ssdb 中

总结 ：感觉这东西挺鸡肋的，单从缓存角度看。 redis 最好只放热数据，且不是特别大的。如果冷数据过多，说明程序有问题。冷数据最好放到 db 中。

# 命中率

命中率 = 命中次数 / \( 命中次数 \+ 不命中次数 \)

redis 中两个值： keyspace\_hits\(命中次数\) \+ keyspace\_misses\(不命中次数\)

缓存的核心指标就是：命中率，这个值不能低于 95%，实际上应该做到99%。不然，这个缓存系统就是有问题的

