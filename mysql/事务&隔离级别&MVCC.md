# ACID

必须满足4个条件:

原子性（Autmic）：一次事务中所有的指令，要么都执行，要么都不执行

一致性（Consistency）：事务的操作应该使数据库从一个一致状态转变倒另一个一致得状态！

持久性（Durability）：一个成功执行得事务对数据库得作用是持久得，即使数据库应故障出错，也应该能够恢复！

隔离性（Isolation）：事务是并发的，多个并发执行的事务相互之间也要隔离的





# 事务隔离级别（Isolation）

#### 概念

从 ACID 原则看：如果多个事务并发执行，应象各个事务独立执行一样！
但事务本就是并发，并发过程中，会出现：两个事务读取同一个数据，两个事务同时修改一个数据。
并没有太完美的解决办法，只能看倾向哪种策略，同时加锁来避免这种情况。


事务的隔离策略会带出3个问题：脏读、幻读、不可重复读

#### 脏读


读取：还未提交的数据。
两个事务基本上没什么隔离，只要某个事务改了数据，另外一个事务立刻就能读到修改后的值。



数据：X=1

A和B 两个事务同时执行，如下：

事务 A 把 X 改成了2
事务 B 读取X为2
此时 B 回退了，并未提交事务。

那么事务A读取的 X=2，  就是脏数据。因为A已经回滚了，X=2是错的，真实的是：X=1

#### 幻读

读取：已提交的数据

一个事务读到了另一个未提交事务修改过的数据

在一个事务中，两次查询的结果不一致(针对的insert操作)

一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。


A 读取  年龄 > 10 的有2条
B 新插入了一条数据，此时：年龄 > 10 的有3条了
A 再读取 年龄 > 10 的有3条了？ 两次 读的结果不一样了

#### 不可重复读

一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。




SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

|**事务隔离级别**|**脏读**|**不可重复读**|**幻读**|
|---|---|---|---|
|读未提交（READ UNCOMMITTED）|√|√|√|
|读已提交（READ COMMITTED）|×|√|√|
|可重复读（REPEATABLE READ）|×|×|√|
|串行化（SERIALIZABLE）|×|×|×|

安全性：
Serializable > 可重读 -> 读已提交  -> 读未提交 

性能：
读未提交 -> 读已提交 -> 可重读 -> Serializable



#### Read Uncommitted

读未提交 的数据，脏读、幻读、不可重复读都会出现，基本上不会使用这种隔离级别。

#### Read Committed

读取已提交的数据 

不可重复读：大部分数据库采用的默认隔离级别。
一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。可避免脏读

指一个事务提交之后，它做的变更才能被其他事务看到

问题：在一个事务中,两次查询的结果不一致(针对的update操作)

select时不添加读锁，就会发生不可重复读问题。

#### Repeatable Read（可重读）

mySql 的默认事务隔离级别，理论上，重读会看到同样的数据行，不过，这会导致另一个棘手的问题：幻读 （Phantom Read）。所以，得加琐，就是支持重读。

可避免脏读，可避免不可重复读，但会出现幻读

指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的
#### Serializable

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。





# MVCC

Multi-Version Concurrency Control：多版本并发控制，相对的就是基于锁的并发控制

读操作：快照读、当前读

快照读：读取的是可见的版本，加的共享锁。如select xxx (for update 除外)

当前读：读取最新版本，会加排它锁。 update delete insert

当前读 例子，update：

1 MYSQL 根据 where -> innodb -> 找到满足条件的数据记录 ->返回 mysql 记录，并加锁

2 MYSQL 发送更新数据 -> innodb- > 更新完成 解锁 -> 返回mysql

update 、delete差不多，insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读

所以，一个MYSQL用户你禁了select操作，update 一样没权限




```c
SET AUTOCOMMIT=0//设置为不自动提交，因为MYSQL默认立即执行

BEGIN

ROOLBACK

COMMIT
```





查看当前会话隔离级别:select @@tx_isolation;

查看系统当前隔离级别:select @@global.tx_isolation;

设置当前会话隔离级别:set session transaction isolation level repeatable read;

设置系统当前隔离级别:set global transaction isolation level repeatable read;

低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。