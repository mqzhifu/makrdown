# 核心模块列表

1. 内存分配
3. 编译过程
4. 内存分配
10. new/make
12. 类/封装/继承/多态/接口
14. 引用/指针/nil
17. 单元测试

## 内存分配


# sleep/timer

原本觉得这东西没必要写，默认就是SYS CALL 内核。

结果：用pprof查看，发现有大量的 runtime.futex 占CPU

又查了下：好像不简单，GOLANG里的sleep 挺复杂

futex : Fast Userspace muTexes

另外为啥要把timer跟sleep一起讲，因为：sleep 底层是timer实现，好惊讶\!\!\!

## timer

创建一个timer，会创建一个管道，然后把该timer甩到timersBucket\(最小堆（四叉树）\)，既然是小根堆 ，那最上面的肯定是时间 最小的。有个调度器，定时扫描这个堆顶即可

区别

sleep:需要被唤醒，即 sleep 后立刻交出执行权

timer:走channel模式，阻塞模式

查了下资料，说：sleep 会放弃执行权，也就是放弃G的执行权。也可能会造成放弃M的执行权，简单说就是：会触发线程级睡眠 ，那么GO的调度器就会很麻烦，要来回切换调度，造成过高的耗费资源 ，但归根结底还是使用timer机制，感觉，也没啥本质区别。


## 排它锁/互斥锁

每次要操作一个数据时，要先获取该锁，否则等待。拿到锁的人，使用结束后，解锁

```go
var mutex sync.Mutex//创建一个锁变量
mutex.Lock()//开始加锁
```


```go
type Mutex struct {
    state int32 //当前锁的状态
    sema  uint32 //信号量
}

type Locker interface {
  Lock()
  Unlock()
}
```


state 是一个 int32，被分成了4个区：

![[golang-锁-state-int32.png]]


Locked:  0 表示没有锁定，1 表示已经被锁定；
Woken: 是否有协程已经被唤醒，0 表示没有协程唤醒，1表示已经有协程唤醒，正在加锁过程中
Starving: 0 表示没有饥饿，1 表示饥饿状态，说明有协程阻塞了超过1ms
Waiter：阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。

#### 自旋和阻塞

在互斥场景下：只有一个线程拿到锁并执行偌大以， 而其他线程都必然是失败者. 
失败者的处理策略有两个:

- 主动等待：进入不断继续重试也就是自旋模式. 可以减少由线程切换造成的系统资源浪费, 这在多核处理器下才有意义
- 被动等待: 阻塞当前进程(线程)切换到其他线程. 当当前线程有长时间的阻塞, 其占用系统资源的造成的代价比线程切换更大时, 这个策略较有意义

#### 模式
- 正常模式，支持自旋
- 饥饿模式，不支持自旋

GO 是使用的混合模式。
默认情况是：自旋模式，也就是乐观状态，每个 协程 都能很快执行完毕，只需要自旋一会即可。
如果发现，等待的协程过多，就会开启饥饿模式

#### 自旋转条件：

- 互斥锁已被锁且处于普通模式 (处于饥饿模式时锁的拥有权会直接交给等待队列的队头)
- 当前运行在多核 CPU 环境中, 且 GOMAXPROCS>1
- 当前 Goroutine 进行自旋的次数小于4
- 至少存在一个其他正在运行的处理器P, 并且它的本地运行队列(local runq)为空 (为了程序整体性能考虑)

>GO的自旋：runtime_doSpin函数，执行了30次PAUSE指令以占用CPU
#### lock 加锁

如果 state.Locked = 0，可以加锁，设置  state.Locked = 1  返回
否则 进入 slowLock 函数
slowLock 先尝试 自旋4 次，如果均失败
当 waiter 超过 starvationThresholdNs(1ms) 没有获取到锁时, 它就会将当前互斥锁切换到饥饿模
循环此过程，直到可以加锁

死锁:函数1中设定了锁X，将X引用传到函数2中，2中直接锁，不释放，然后return.函数1执行流继续，这个时候，如果函数1想再加锁...阻塞

#### 解锁



默认=0：未使用
1=mutexLocked:锁定状态
2=mutexWoken:从正常模式被从唤醒
3=mutexStarving: 当前的互斥锁进入饥饿状态
4=waitersCount — 当前互斥锁上等待的 goroutine 个数


在 Lock() 之前使用 Unlock() 会导致 panic 异常

# 读写锁

一个资源，可以加读锁或写锁

其中：

如果一个协程加了读锁，另一个协程也可以加读锁，但不能加写锁了

如果一个协程加了写锁，其它协程不能加任何锁了

写锁优先集高于读锁

这种锁，适合读多写少的情况



