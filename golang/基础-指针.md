
# 数据类型



|  |  | 分类 |
| :--- | :--- | :--- |
| bool | true false | 基本 |
| string | []byte | 基本 |
| int | int<br>uint8 uint16 uint32 unit64 <br>int8 int16 int32 int64<br>byte<br>rune<br>uintptr<br>complex64 complex128 | 基本 |
| float | float32 float64 | 基本 |
| array | 数组 | 复杂类型 |
| slice | 切片 | 复杂类型 |
| map | hashTable | 复杂类型 |
| chan | 管道 | 复杂类型 |
| 指针 |  | 复杂类型 |
| struct | 结构体 | 复杂类型 |
| interface |  | 复杂类型 |
| 函数 |  | 复杂类型 |
|  |  |  |
|  |  |  |

#### byte

byte = uint8

字符串：C语言中的字符串是字符数组，但GO里是字节数组，也就是一个字符对应的 ascii 码值。

#### rune

```go
rune := int32
```



string 最终底层的字符处理实际是：utf-8，如：

```go
a := 123中国
```
如果len(a)：3+3+3=9，一个汉字如果是 UTF-8 是占3个字节

```go
a := 123中国
```
如果len(a)：6，它把汉字当成了一个字符的长度


#### uintprt

一种无符号整型类型，可以保存一个指针值，也可以进行指针运算，但是它并不是一个指针类型，所以不能直接用来取值。

```go 
type uintptr uintptr
```

想要取值的话，需要通过 unsafe.Pointe r转换到具体类型指针后，使用 \* 号取值。

```go
addr := uintptr(unsafe.Pointer(ptr)) 
```

>感觉 uintprt 是对 指针又封装了一层

#### unsafe.Pointer

unsafe.Pointer：也是一种类型。
可以将任何类型的指针转换为unsafe.Pointer类型，也可以将unsafe.Pointer类型转换为任何类型的指针
unsafe.Pointer 可以作为桥梁，将使用"&"取的地址转换成 uintptr 进行指针运算










# 引用/指针

都是操作内存，内存原理可讲的东西太多，忽略了先。

先说指针，定义一个变量名：PP，类型为指针，同时该指针只能指向int类型的地址

> var pp \*int
> 
> 
> i := 1
> 
> 
> pp = &i

试着输出下：

println\(pp\)

> 0xc00040a008

println\(\*pp\)

> 1

简单理解下：PP是个变量，该变量里保存的是一个地址\(引用\)~直接输出该变量，是一个地址，而加上\*号，即把该地址指向的值输出
