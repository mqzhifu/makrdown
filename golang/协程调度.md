
# 概览

#### 传统模型

![[golang-传统线程模型.png]]

传统模型：开发者调用系统的API，创建线程，线程最终在 CPU 执行。
优点：开发者比较简单
缺点：OS 调试 线程 比较吃性能

#### golang 模型

![[golang-线程模型.png]]

golang 把线程的调度写在了用户态
优点：性能更好
缺点：部分情况，线程的调度不如OS

# 术语


|  |  |  |  |
|:---|:---|:---|:---|
| M | machine | 真实的一个线程，执行一个 goroutine |  |
| P | process | 介于GM之间，调度G和M |  |
| G | goroutine | 一个协程 |  |
| allP | process list | 存储所有的P |  |
| allM | machine list | 存储所有的M |  |
|  |  |  |  |
|  |  |  |  |  

GOMAXPROCS：函数用来控制，开多少个P。
#### runtime

包含了调度、内存管理、垃圾回收、内部数据结构、定时器和各种系统调用的封装等。
>可以说golang的强大都归功于 runtime 的实现。
>GMP的核心也是  runtime

#### Local Run Queue

本地运行队列，每个P都包含一个
执行G时，先从LRQ中找G，如果没有 再从 GRQ 中找。

#### Global Run Queue

全局运行队列

# 启动过程

![[golang-启动过程.png]]
指令行，启动 go 程序：
1. shell 会创建一个进程
2. 进程会创建一个线程(主线程 m0)
3. 之后的代码在主 m0 上开始执行


```C
CALL runtime·args(SB)

CALL runtime·osinit(SB)
CALL runtime·schedinit(SB)


//2.2 调用 runtime·newproc 创建一个协程
// 并将 runtime.main 函数作为入口
MOVQ $runtime·mainPC(SB), AX // entry
PUSHQ AX
CALL runtime·newproc(SB)
POPQ AX

//2.3 启动线程，启动调度系统
CALL runtime·mstart(SB)
```

1. runtime·args：初始化执行文件的绝对路径
2. osinit：CPU 个数  、内存页大小
3. schedinit：
	- worldStopped：先停止GC
	- stackinit：初始化栈
	- mallocinit：初始化堆
	- mcommoninit：设定M个数 获取当前G 绑定M和G  设定 allM
	- gcinit：初始化垃圾回收
	- procresize：创建P列表，对新 P 进行内存分配和初始化
	- worldStarted：恢复GC
4. newproc：
	- 创建一个G，绑定 runtime·main 
	- 把G 插入到P 的 runQueue 中
	- wakeP
5. MStart:
	- 创建一个G，创建一个线程
	- 把G加入到 allG中
	- schedule
6. schedule
	- 从P中找一个G,用来执行 main goroutine
	- 死循环
7. main  goroutine
	- 创建一个M，执行 sysmon
	- 创建一个G，执行 gc_nable
	- 调用 用户的 main 函数
8. 程序在 schedule（findrunnable） 进入了死循环 
9. main  goroutine 执行体，算是最初的执行体，此函数被压到在栈的最底部
>这就是 main 一但结束了，其它 协程全结束的原因


>自旋：如果M在 本地队列/全局运行队列/netpoller中，找不到工作  
(M进入了一种循环找可运行G的状态)


# GPM

![[golang-gmp.png]]


实际就是对这几个结构的体的控制，就实现了：协程 

#### G状态：

空闲中
待运行
运行中
系统调用中
等待中
已中止
栈复制中

#### M状态
>实际上它并没有这些状态，但如下算是虚拟的

自旋中
执行Go代码中
执行原生代码中
休眠中

#### P状态

空闲中
运行中
系统调用中
GC停止中
已中止

```C

type g struct {
	stack stack // 描述了真实的栈内存，包括上下界
	m *m // 当前的m
	sched gobuf // goroutine切换时，用于保存g的上下文
// 用于传递参数，睡眠时其他goroutine可以设置param，唤醒时该goroutine可以获取
	param unsafe.Pointer 
	atomicstatus uint32
	stackLock uint32
	goid int64 // goroutine的ID
	waitsince int64 // g被阻塞的大体时间
	lockedm *m // G被锁定只在这个m上运行
}

```

```c

type m struct {

	g0 *g // 带有调度栈的goroutine
	gsignal *g // 处理信号的goroutine
	tls [6]uintptr // thread-local storage
	mstartfn func()
	curg *g // 当前运行的goroutine
	caughtsig guintptr
	p puintptr // 关联p和执行的go代码
	nextp puintptr
	id int32
	mallocing int32 // 状态
	spinning bool // m是否out of work
	blocked bool // m是否被阻塞
	inwb bool // m是否在执行写屏蔽
	printlock int8
	incgo bool // m在执行cgo吗
	fastrand uint32
	ncgocall uint64 // cgo调用的总数
	ncgo int32 // 当前cgo调用的数目
	park note
	alllink *m // 用于链接allm
	schedlink muintptr
	mcache *mcache // 当前m的内存缓存
	lockedg *g // 锁定g在当前m上执行，而不会切换到其他m
	createstack [32]uintptr // thread创建的栈
}

```

```c
	type p struct {
	lock mutex	
	id int32	
	status uint32 // 状态，可以为pidle/prunning/...	
	link puintptr	
	schedtick uint32 // 每调度一次加1	
	syscalltick uint32 // 每一次系统调用加1	
	sysmontick sysmontick	
	m muintptr // 回链到关联的m	
	mcache *mcache	
	racectx uintptr	
	goidcache uint64 // goroutine的ID的缓存	
	goidcacheend uint64	
	// 可运行的goroutine的队列	
	runqhead uint32	
	runqtail uint32	
	runq [256]guintptr	
	runnext guintptr // 下一个运行的g	
	sudogcache []*sudog	
	sudogbuf [128]*sudog	
	palloc persistentAlloc // per-P to avoid mutex	
	pad [sys.CacheLineSize]byte
}

````

从结构上看，G会绑定M，M会绑定P和G，P会绑定M

runtime.main会额外创建一个纯种，执行sysmon