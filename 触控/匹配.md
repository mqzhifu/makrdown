# 概述

玩家想要玩对战类的游戏，报名后，系统给匹配出对手.

# 角色定义

|序号|key          |描述    |
|----|-------------|--------|
|1   |player       |玩家    |
|2   |game client  |游戏前端|
|3   |game server  |游戏后端|
|4   |room service |房间服务|
|5   |match service|匹配服务|

# 角色交互图


  
## 流程图
```mermaid
graph LR
A(玩家) -->|报名| B(游戏前端)
B --> C(游戏后端)
C --> D(房间服务)
D --> E(匹配服务)
E -->|请等待| D
D --> |请等待|C
C --> |请等待|B
B --> |报名成功请等待|A

```


```mermaid

graph LR

E(匹配服务) -->|结果| D(房间服务)

D -->C(游戏后端)

C -->B(游戏前端)

B -->|开始游戏|A(玩家)

```
## 时序图
```mermaid

sequenceDiagram

玩家->>游戏前端: 报名

游戏前端->>游戏后端: 报名

游戏后端->>房间服务: 报名

房间服务->>匹配服务: 报名

匹配服务->>匹配服务: 存储玩家数据

匹配服务-->>玩家: 报名成功，请等待...

房间服务->>房间服务:等待中

游戏后端->>游戏后端:等待中

游戏前端->>游戏前端:等待中

玩家->>玩家:等待中

匹配服务-->>玩家: 匹配结果

玩家->>玩家:开始游戏

```

#  权重

## 玩家权重计算

一个玩家的权重：根据 请求方 附带的 玩家属性值，代入到公式中，先计算聚合函数，最后 计算表达式的值

## 公式定义

1. 公式 ,avg \(age\) \+ gold \* level \- 20
2. 权重值匹配范围 ,1 ~ 3
3. 是否接受调配，如在指定的范围内匹配不到对手，是否可放大搜索范围
4. 聚合函数:sum max min average


# 匹配规则-基础配置

1. 成团人数
2. 报名超时时间
3. 匹配成功后超时时间
4. 权重
5. 请求方附加字段，匹配成功后如实返回
6. 模式
    1. N人组团，如：吃鸡
    2. N VS N 组队互相PK，如：王者荣耀

# 匹配计算方法

1. 全检索/模糊搜索
2. 块检索
3. 递增检索
4. 自定义检索

## 全检索/模糊搜索

每次匹配计算时，都会优先触发此种检索方法。
该方法：直接统计总人数、总小组数，如果人数太少，后面3种检索就没必要了。如果总人数\<2倍\(满足人数条件\)，也会跳过后面3种。

## 块检索

0~1
1\-2
...

8\-9
9\-10

它是把总分分成10个块，依次去处理每个块的玩家

## 递增检索

0\-1
0\-2
...

0\-7
0\-8
0\-9
0\-10

它是依次递增的方式，处理每个块的玩家

## 自定义检索

0\-1
0\-2
1\-3
2\-4
3\-5
4\-6
...

他是即包含了上一次块的一部分数据再加下一个块的一部分数据，属于偏折中的方式检索

## N VS N 匹配公平性

比如，5人组队，优先匹配其它的5人组队，保证公平性

## 推送重试机制

当匹配成功 或 匹配失败，结果需要推送给调用方时，需要推送操作， 目前是重试3次，如果对方均无法正常接收，不会保存该数据，直接删除

# 守护协程组

主协程：

1. 信号处理
2. main
3. http
4. Metrics

rule协程组：每个rule 会有如下3个守护协程

1. 匹配成功超时检测
2. 匹配计算
3. 推送

log协程组：每实例化一个log 会有一个协程负载接收消息，并负责写入磁盘

1. main
2. http
3. 每个rule 都会4个log
    1. 匹配成功超时检测
    2. 匹配计算
    3. 推送
    4. 报名

总协程数计算：4\(主协程\)\+2\(log\)\+rule数量 \* \[3\(守护协程\)\+4\(log\)\] = 6 \+ rule数 \* 7 = 6 \+ N \* 7

这里假设N=5 ， 6 \+ 5\*7 = 41

## 不支持/待解决功能

假设现在有A\(北京\) B\(上海\) C\(上海\) D\(北京\)

rule配置规则不变，想把：上海跟上海的匹配到一块，北京的跟北京的匹配到一块

# 负载均衡

假设A公司，有100个rule配置条目，脚本布置在机器1上，之后，发现机器1的负载较高，想做横向分拆。

1. 先确定是哪些条目访问量比较大，比较吃服务器资源
2. 确定好ruleIds后，停止旧进程，在新机器开1个进程，参数配置里：指定监听的ruleId即可。同时旧进程在旧服务器重新开启，一样：指定监听的ruleId即可。

> 一个rule配置条目会对应一个队列，所以横向随便拆分，放在N台机器上

负载过高的多个rule在一台机器上，被拆分到多条机器后，即解决了单进程处理多个rule的情况，那如果，单rule负载又非常高呢？

入口加一个负载器，多台机器还是正常启动匹配进程，注：redis要拆分，或者redis

# 日志

1. 程序异常
2. 主日志
3. http IO
4. 报名
5. 取消报名
6. 报名异常
7. 匹配成功
8. 报名超时
9. 匹配成功超时
10. 推送
11. 报名
    1. 报名成功
    2. 报名失败
    3. 报名超时
    4. 取消报名
12. 异常数据
13. 推送数据
    2. 匹配成功超时
    3. 推送失败丢弃
    4. 重试日志

## 数据持久化

1. 玩家基础：状态、playerId、超时时间
2. 玩家权重
3. 小组
4. 匹配成功结果集
5. 推送

