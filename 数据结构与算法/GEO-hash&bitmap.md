# GEO-hash&bitmap

gep\-hash

用一个字符串表示经度和纬度，但不是精确表示，而是范围表示

先把 经纬度，用2分法，分开，如：\-90，90 分成 \-90，0 0，90

假设有 经度：39.92324，他属于第2个分区，于是第1位就为1

然后，把0,90 再分2个区 0,45 45，90

它属于第1个分区，于是 第2位为0

依此类推吧~ 最后得出一个2进制串~~位数越多，越精准

纬度，也这样计算，最后得出一个2进制串

然后合并经纬度，从A串中第1个位置取出一位，再从B串第1个位置取出1位，合并 ，然后，依此类推

结果：奇数位是纬度，偶数位是经度

这样得出一个总串~再BASE32一下~

实际上，这种 方法是将 椭圆的地球，平铺开~成为一个2维坐标系（分块/区）~再将2维转换成1系（一维曲线）

会有 临界值 计算不准的情况

bitmap

排序

假设 数字范围：0~7，当前给出集合{4，7，2，5，3}

先开辟一个字节并置成0：0 0 0 0 0 0 0 0

循环集合，第一个元素是4，也就是位置为4，把字节置成：0 0 0 0 1 0 0 0

依次类推得出：0 0 1 1 1 1 0 1

优点：不需要进行比较和移位 、占用内存少

缺点：所有的数据不能重复

基数查找\-去重查找

计算用户UV，假设用户ID 范围为：10000000~9999999

比如有10亿个用户访问记录，查找基数

一个整数4个字节~10亿X4=40亿个字节/1024/1024/1024=3.725G

全加载内存有点坑

开辟一个字节\-数组（内容缓冲区）大小为：9999999 /8 =1249999.875 约1.19MB

将UID 映射到 这个数组的位置 ，存在 即为1 否则为0

