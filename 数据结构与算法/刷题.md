# zigzag

Base 128 Varints 编码（压缩算法）

int：有符号整形，占4个字节（32位），如：

数字 1转换成2进制\-\>00000000 00000000 00000000 00000001

数字\-1转换成2进制\-\>11111111 11111111 11111111 11111111

我们发现数字1转换成2进制后，前面有31个0，都是占位符，能不能优化掉？肯定能，分析:

1. 正数前面的0可以直接干掉
2. 负数不行，在计算机中会被自动转换成补码，也就是占位符变成了1
3. 核心点：解决负数问题
4. 第一个问题要解决的就是符号位问题，将第一位符号位移到末尾

尝试将符号位移到末尾

先左移一位：

> 1 \<\< 1 == 00000000 00000000 00000000 00000010
> 
> 
> \-1\<\< 1 == 11111111 11111111 11111111 11111110

左移操作，不管有符号还是无符号，末尾统一补：0。

以上，数字的最后一位都被补上0了

---

再将数字右移31位：

1 \>\> 31 = 0

\-1\>\> 31 = 1

右移，如果无符号首位补1，否则首位补0

右移31位后，取得了符号位

如果这个时候直接将两步的结果做或运算，就等于：将首位\(符号位\)移到了末尾，如下：

\( 1 \<\< 1 \) or \( 1 \>\> 31 \) == 00000000 00000000 00000000 00000010

\(\-1 \<\< 1 \) or \(\-1 \>\> 31 \) == 11111111 11111111 11111111 11111111

我们发现正数没什么变化，负数又变成了一堆1了，所以还是得处理负数问题，如果负数再做一个反码操作（符号位不变）

> 11111111 11111111 11111111 11111111 \-\> 00000000 00000000 00000000 00000001

终于把负数的占位符都转化成0了\!

---

但还有更巧妙的算法，将 或 运算与 取反运算合并成一步，异或：

00000000 00000000 00000000 00000010

00000000 00000000 00000000 00000000

00000000 00000000 00000000 00000010

11111111 11111111 11111111 11111110

11111111 11111111 11111111 11111111

00000000 00000000 00000000 00000001

> 最终：代码公式：\( n \<\< 1 \) xor \( n \>\> 31 \)

---

解压

1. 先判断最后一位，正数最简单，移动一下符号位即可
2. 负数，得先做\<非\>操作（最后一位符号位不动），然后再将符号移到首位

---

传输

虽然实现了压缩算法，但是如何将0删除，如何传输还得再定义

1. 把数据中前置占位符删除掉
2. 将余下的字符除以7，进行分组

> 如：zigzag编译后 1000110 011001 ，分成两个组：1000110 011001

1. 传输时最小的组单位是字节 ，8个二进制位，而这里以7位分组空出一位，即用来标识：后面是否还有数据

> 如：1000110 011001 这是两组，也是两个字节，每个字节还能再使用空出来的一位，在1000110前面加1，代表：该组数字要跟后面合起来一起使用，011001 后面没了，所以在其首部加上0最终就是：11000110 0011001

