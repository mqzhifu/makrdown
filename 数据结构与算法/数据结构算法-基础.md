# 概述

数据结构：是一种数据的存放方式。如：对现实社会的建模，用户数据表
算法：是对数据结构的计算。如：查找某个值，对数据进行排序等

为什么这两个东西总是被放在一起说?
因为：算法，算的就是数据，而影响算法最大的就是数据的结构\(存储方式\)。不同的数据结构算法也不太一样，有点相辅相成的意思。

分析

1. 任何算法都是基于某种数据结构，单独谈算法纯属扯蛋，不同的数组结构同一算法，差距非常大，返过来也一样，不同的算法相同的结构，差距也非常大
2. 在数据量不大的时候，谈算法也是扯蛋，因为最好的算法跟最差的算法，基本时间相近，反而比较好的算法需要更多的时间去开发维护，增加了复杂度。

> 为什么面试揪着数据结构与算法不放？所有大公司都问这个？

这两个东西影响着计算机系统的千千万万，并不局限是后端还是前端、是软件还是硬件、是现实还是虚拟。算法的进步推动了整个计算机体系的发展与进步，所以，它是：基础中的基础....

# 分类：

|大分类|存储方式 |结构                        |应用|
|------|---------|----------------------------|----|
|线性  |顺序     |数组                        |    |
|线性  |链式     |链表                        |    |
|线性  |顺序/链式|队列                        |    |
|线性  |顺序/链式|栈                          |    |
|树    |顺序     |堆                          |    |
|散列表|顺序/链式|哈希                        |    |
|树    |链式     |二叉树/平衡树/红黑树        |    |
|树    |链式     |2\-3树/2\-3\-4树/B\-树/B\+树|    |
|      |         |图                          |    |

# 线性结构

一组数据集合：类型相同，如：int float bool struct 等。将这一组数据用一根线串起来，组成一个集合。数据的添加/删除是横向/纵向的，所以他像一根笔直的线

根据存储结构不同，又可分为：

1. 顺序存储结构
2. 链式存储结构

> 具体分析后面做讲解

# 非线性结构

# 大O表示表示法

在计算一个算法的好坏\(复杂度\)时，可以使用大O表示法。它的核心就是：给一个算法推算出一个大概的公式。

> 各种算法的好坏：时间复杂度、空间复杂度，都有些公式统一换算成一个公式，帮助做比对分析

# 数组\(线性\)

原理：在内存中开辟一段连续的空间，再对该空间进行等份划分,最后供程序员使用。

> 如：a = new array\(10\) int32 ,一个int=4bytes，数组大小为10，10 \* 4bytes = 40bytes ，那么OS会再内存中，找一段空白的40bytes空间，并将该内存地址传回给变量a

优点

> 一段连续的内存地址等于有了段地址，操作元素时，偏移即可，像：遍历、操作都较快。有下标地址，操作也简单。

缺点

> 必须固定大小，申请大了造成浪费，申请小了扩容很麻烦。插入/删除操作，要对整个内存地址进行移动，这个吃性能很大。

# 从功能性分类

## 无序:随便存

> 插入是O\(1\) 查询是O\(N\) 删除是O\(1\)

适合场景：插入的操作多，删除的操作多，查找的操作少，排序的操作少

## 有序:添加元素时，遍历整个数组的所有值，找到应该放置的位置，然后，按照大小依次存放

> 插入是O\(N\) 查询是O\(logN\) 删除是O\(N\)

适合场景：排序的操作多，查找的操作多，插入的操作少，删除的操作少

> ps:从适合场景中也能看出，没有什么完美的算法，都有各自的优缺点。取决于业务形态，又或者这两种算法同时生效。

组中的元素值是否可重复？

不允许：插入的时候，得先遍历整个数组的所有元素

允许：

1. 在申请数组大小的时候得注意，因为，申请数组大小为100，但可不一定能放100个人，也可能只放50人\(另外50人是重复的\)
2. 删除的时候想好是删除一个还是重复的元素全删除
3. 添加的时候得考虑好，重复的值是统计放成连续的，还是不连续。如果是连续的，那还得考虑后面的元素做移动
4. 查找的时候得想好，是找到一个即返回，还是得找出全部

> 看起来，允许重复很复杂，不允许重复反倒简单，但依然还得有个O\(N\)遍历操作

数组的长度计算

这个长度可不等于数组的大小，因为创建一个100元素的数组，很可能实际只存了20个值，那么这个数组的实在存储长度仅仅是20。算法：

1. 单独再开一个变量，每次加减操作，这个数字 累加累减
2. 每次都遍历整个数组，动态计算最终长度

## 总结

数组的缺陷性挺大的，正常一个功能，不可能没有删除/添加，一但有类似操作，要么遍历整个数组，要么就得调整整个数组的元素位置，很麻烦。还有，大小固定，一但元素过多/过少还得考虑减少/扩容问题。还有它的是否可重复问题处理起来也挺头疼。

严格来说：数组并不适合做单独的算法，可以配合其它算法一起使用\(Hash\)。或者没太复杂的操作，只是单纯的存一些有共性的值。如：一个大功能中的一小段代码，需要临时有个容器存点东西。

# 链表

在内存中开辟一个值，存储一些小数据，同时再开N个这样的值，最后将这些小的内存数据连成一起。
每个节点数据：除了存数据外，额外还要保存2个值，它的上一个节点的地址，和它的下一个节点的地址

分类：单向、双向、循环、有序、无序

优点：内存存储结构比较松散，扩展性强，不需要固定申请内存长度，插入删除较快，比较灵活。
缺点：内存不连续，读取性能慢，没法通过段/偏移值快速定位一个元素位置，得一个一个遍历的查。

表头 插入或者增加 O\(1\)
查找是O（n） 删除 O\(n\) 任意位置添加 O\(n\)

优点：扩展性强，不需要固定申请内存长度，插入删除较快

缺点：遍历略慢点，另外内存并不是连续的，遍历略慢点

适用的场景，非常多

1. 栈
2. 堆
3. 队列
4. hashMap
5. 各种树
6. 迭代器

# 树

[跳转](https://app.yinxiang.com/fx/e65e71b4-1ad7-4af3-ba05-6f12cd8a4353)

# 排序算法探索

[跳转](https://app.yinxiang.com/fx/46a7c5fa-06e3-4b48-a6b7-f1d911fe0a17)

# HASH

> hash:散列、打碎、哈希\(音译\)，因为是个外文，也没精准的翻译
大概的意思是：给定一个值\(数字|字符\)，根据一个算法，将此值转换成一个新值（不定长）

> 如此简单的东西，人人都可以搞一个，有毛用？
它的使用场景，大体看有2个大方向：

1. 数据分片|分布式，即把一个大的集合划分\(hash函数\)成若干小的子集合，当有请求过来根据hash函数，找到特定的那个小集合中
    数据均衡，一个值，能均衡的将此值分发到若干的子集合中去，跟上面类似
2. 将字符串，转换\(hash函数\)成一个新的字符串

由两个大方向，推导，细分领域：

|名称       |描述                                                               |算法|
|-----------|-------------------------------------------------------------------|----|
|加密/签名  |传输文件时，对文件内容进行hash后，得到一个，简短签名               |md5 |
|压缩       |对一堆字符串，使用hash函数后，得到一个定长简短的字符串             |md5 |
|负载均衡   |根据特定值\(ip\)，使用hash函数后，决定该请求指向哪台机器IP         |求余|
|数据分片/块|根据特定值\(如数值的个位数\) ，使用hash函数后，找到真实数据存储的块|求余|
|分布式     |跟上面类似                                                         |求余|

签名

> 假设A有个文件要传给B，但害怕在传输过程中该文件内容被黑客截获篡改，于是，A把文件里的所有字符串用hash，在传输的时候：把该串\+文件一并传过去，B拿到文件跟定长串后，也重复A的算法，最后比对两个定长串是否一致。

加密

> 跟上面的有点像，给内容通过hash函数，转换成一个新的内容
> 
> 
> 区别:上面是只生成一个串即可，而加密要给逐断给内容用hash加密

压缩

> 现有100W个URL地址，长度各异。要求尽快的统计出每个URL的次数，如果一个一个URL的比较，就是一个字符一个字符的比较，效率有点低，如果用hash函数把这种长度各异的URL地址，统一转化成固定长度且字符量较小的串，效率更高

负载均衡

> 假设，现在有3台服务器，给每台服务器设置ID，1 2 3 ，根据请求的IP，最后一位数值，与3求余，决定该请求最终真实的处理的服务器

大数据分块

> 假设当前数据库里存储了100W用户，每次查询时，要扫描整张表\(未建索引\)，这时将单张表，拆分成10张表，根据用户ID最后一位，与10求余。

分布式

> 跟上面类似

做一个DEMO，数据分片/均衡：

> 给定一个集合，按照一定算法，将这集合里的元素值，分成若干个子集合，并把值映射进去。
> 
> 
> 这里就拿数组做实现吧，略形象些

申请了一个大小为：100个元素的数组，

> arr = new array\(100\)

划分子集合：数组就是一个大集合，将其分成10等份

> 即：1\-10，11\-20....91\-100

假设现在过来100个数\(随意的数字\)，要如何平均分散插入到这个数组中呢？

> number % 10 = mod

要添加的数字，跟10求余，其结果肯定 是：0~9，根据这个余数去找对应的子集合，然后顺序存储即可

> 这个hash函数有什么用？

这里的DEMO比较简单，如果把这10个子集合，看成若干台机器，把100个数再放大到无限大时，即可实现了：多台机器存储同一业务的功能，即：分布式，同时也有一定的负载均衡的功能。

这里做了一个分治/分片/均衡的DEMO,但还有几个问题？

1. 数组大小是100，即：只能装下100个数字，如果此时要插入1000个元素咋办？

> 一致性哈希

1. 给定的100个数值是递增的，那求余后，基本上是平均散落到这10个子集合中，这是理想状态，如果不是递增的话，比如：个位数全是1，那么，还是存不进去...

> 这个就是数据的散列度与hash函数的选择了

1. hash后，重复值如何处理？

> 这种情况叫：碰撞，使用拉链法

## 数据散列度

上面问题2中：发现，一但数据大部分以1结尾，那么，只能就一个数组有值，其它子集均为空，且无法实现分片功能。又或者，所有数据都是以1和2结尾的，就变成了只有2个子集合有值，而预期是希望：10个数组最好都有值

以上就引出了两个问题：

1. 数据集合中的值，是否适合用hash结构？
2. hash函数是否适合 数据集合中的值？

解答1：数值，什么样的集合适合？

1. 顺序递增，如：数据库的自增ID
2. 随机数
3. 可预知集合，如：集合中的数字是固定的，且轻易不会变的

解答2：hash函数的选择，要先查看下集合中的数值情况，再决定使用什么样的hash，并且有些数据值可能根本就不适合用hash结构

## 解决碰撞/拉链法

假设，当前有两个值：aa bb ，正常经过hash函数后，得出 1 和 2 ，这两个数代表的是数组的下标，存储的时候，即：arr\[1\] = aa , arr\[2\] = bb ，这时加了个C，经过hash函数后：2，出现了碰撞，那么该如何存储？这个时候给arr\[2\] 不存真正的值，而是存一个地址，地址指向一个链表\(也可以用数组\)，所有重复的值都在这外链表中。这种方法的缺点是：要增加额外的空间

## 开放地址法

线性探测

还是上面的情况，计算出哈希值=2，但是arr\[2\]，已经有值了，这个时候探测，去查找arr\[3\]，有没有值，如果没有，就存在这个位置，查找 的时候，肯定是先拿arr\[2\]里的值，发现不对，线性探测，也就是找arr\[2\]下面的值。那如果这时候 arr\[3\]要存值咋办？顺延，依次递增吧~ 一但发生这种情况，就等于所有元素再添加的时候都要被顺延，挺可怕的，这种情况叫聚集。另外，原本可以存100个不同元素值的数组，现在变成了只能存99个了....

```
二次探测
    跟上面差不多，只是：当发生碰撞后，向下递增长空位，改成：更大范围查找，如：X+1、X+n^2
    ，只是加大了个步长，还是没解决核心问题

再hash法
    如果出现碰撞，就换种hash法，肯定能得到不同的值~
```

> 感觉，以上3种方法，看着一个比一个秀，但都躲不过一个核心问题：数组的容量有限，只要多一个值，就得少存一个，并且会改变原来的 下标

问题2：这个得分成两类来看，如果是上面URL的例子，那就死局没办法，只能找个更好的hash函数，将碰撞降到最低，另外，URL的统计本就是个统计学的东西，就是个大概值就够了，有个1%的误差，其实无所谓的。但如果不是URL，像加密这种，1%的错误率也是挺可怕的，依然无解没太好办法。

如下我找了几个hash函数算法：

|算法名称|描述                                  |适用                                   |
|--------|--------------------------------------|---------------------------------------|
|md5     |太复杂了，不写了...                   |密码、名称、统计URL个数时用的多        |
|time33  |一个固定值 \* 33 \+ 一个字符串\(asci\)|字符串转成int，具说效率最高，散列最好  |
|求余    |X MOD N                               |最简单的函数，但当N发生变化时，问题较大|
|        |                                      |                                       |
|        |                                      |                                       |

> 算法的具体实现就别深入研究了，看了看MD5太复杂了...知道每种算法适合的领域吧...

优点：插入是O\(1\)，删除O（1），查找O（1）

缺点：

1. 会有碰撞值，一但KEY取不好，就完蛋。另外，还必须得平均分散
2. 它是基于数组的，初始的大小一但建立，后期产生变化有点麻烦
3. 不太好遍历
4. hash函数的选择

这些时候都是最基础的，正常面试会问：

1. hash分片后，如果遍历整个集合？

> 额外建立二级索引

1. 具体某些hash函数的算法实现

> time33 md5

1. hash重复值的处理

> 拉链法、开放寻址

1. hash的散列度预估及hash函数选择

> 这两其实是考核下自己对整体数据的预估，及哪些数据类型适合HASH结构，还有每种hash算法的核心

1. hash如何实现hashTableMap

> 这个应该是最复杂的，最难讲的，而且，不同语言的实现也不太相同，回头我统一找个地方好好写写吧.

1. 如果数据发生变更，原hash函数的散列平衡被打破，如果处理？

> 一致性hash算法

# 栈

先进后出，只有一个出口，只有一个入口，不允许从栈的其它位置有任何操作。也就是说：没有遍历/查找操作，只能添加/删除操作。

插入是O\(1\)，删除O（1）

使用场景

1. 安卓的\<后退\>功能，进入一个页面就把URL压入栈，这样点击后退按钮的时候，是一层一层的向上后退。
2. 解释器：遇到一个 左括号就压入线，遇到一个右括号就比对，因为一个程序中可能嵌套很多个
    括号，这样保证最近的一个 匹配。
3. 算术表达式中对括号的处理，跟上面有点类似
4. 程序执行器，正常我们程序中定义的常量、变量、函数入口地址等都会被压入到栈中
5. 单词做逆排序

存储容器：栈只是一种算法，每个栈里的元素得进行存储，而存储就可以考虑用数组，也可以用链表。

算是一个小众的算法结构，基本上日常做应用开发，用不到这种。而底层开发用的可能略多一点点，但只适用于特定的场景，还是比较小众。或者说 跟其它算法组合成一个更大的算法。

# 队列

先进先出

无序队列、优先级\(有序\)队列、循环队列、双端队列

> 个人觉得分类挺多，实际大同小异，且应用最广的就是最普通的：无序队列，先进先出

插入是O\(1\)，删除O（1）

像：对'顺序'有要求的、将并化转串化等

队列的使用是非常广的，主要是很并行的消息进行串化缓存/暂存，按时间进行顺序存储，如：顺序的加、顺序的取。有一定的容错、持久化功能。

而且，队列已经完全可以大到单独成为一个软件\(消息中间件\)，像：

kafaka rabbitmq rocketmq 等

存储容器：链表、数组都行，具体看业务需求。我更倾向用链表，因为 添加/删除 更快~

代码实现：核心就是定义两个变量\+一个容器，一个指向队头，一个指向队尾....

应用场景，这个太多了

1. 秒杀，将大并发进行串化
2. 解耦两个业务
3. 异步处理

优先级\(有序\)队列：添加的时候，除了数据还会多一个权重\(索引\)值，队列里的每个元素会根据这个值进行排序，最后权重值高一点的，可能会早一点出去。

> 所以，从优先级队列看，用链表当容器可能灵活性更高一点~删一个/加一个元素不用移动所有元素

应用场景

1. 发短信，不同部门的有不同的发顺序
2. 进程抢占式应用

插入是O\(N\)，删除O（1）

# 堆

> 各种语言中，大类型的内存申请，经常提到：堆，像：对象、数组等，但跟这个堆不是一个东西，这里只是一种结构
> 这里指的是：大根堆、小根堆：树结构

就拿小根堆，看下，堆的限定条件 ：

1. 是一个完全树
2. 插入新节点时：一定是从树的最后位置插入
3. 每个子节点\(左右都是\)都要比父节点大

> 挺简单，就3条

分析特性：

1. 因为是完全树，最差结果：最后一层不平衡，且每次新加节点是最后，即：该树肯定是最底层由左往右添加
2. 顺着任意节点向上：肯定是降序的，由根向下的任意路径肯定是升序
3. 根节点的关键值，肯定是最小的
4. 虽然是棵树结构，但是它没有限定左子节点一定大小\(小于\)右子节点，就不是搜索二叉树，也就是CURD操作更简单

> 结合以上4点来看，实在起来，就一个点麻烦：如何获取最后一个节点的位置？\(插入的时候得先确定位置\)

链表可以实在，但是计算这个最后节点有麻烦，再结合他是一棵：完整二叉树且是一直连续的，没有空的洞，那么：用数组实在更简单

结论：

虽然也是树形结构，但是它的限定条件：相比于搜索二叉树没那么严格，实现起来简单，操作起来也简单，自然速度也更快速，适合一些小场景使用，另外因为是一个完整树的且连续的，用数组容器效率还会更高

1. 可以用来做些极值访问频繁的情况:top k
2. 大部分的实现容器，使用的是数组

删除操作

以删除根节点为例子，删除后，得对树节点做出调整，那么取出最右侧的节点，换到根节点，然后，对原根节点 的左右两个节点进行比对，与大的节点进行换位置，循环此过程

> 它的树调整：是从上而下的

插入操作

以插入最右侧值为盒子，比对树最右侧的值，然后对调，对调后，判断父节点，继续重复此过程

> 它的树调整：是从下而上的

> 之前一直以为是顺序存储，就是个有序数组

应用场景：

1. 排序

> 先弹出堆顶的，然后拿最右侧的值，逐步向上比较，再弹出堆顶

1. top K, 从100万个数中找出最大\(小\)的前k个

> 开设一个堆结构的数组，大小为K来，每次数据有插入/删除操作，即更新此数组，溢出的直接扔掉

1. 中位数

> 有两个堆结构，一个大根堆，一个小根堆，两个根各存一半的数据，即：小根堆的数据均大于大根堆的数据
> 
> 
> 最后，如果集合的元素总数为偶尔时：两个堆的堆顶元素即是中位数，奇数个时，小堆根的堆顶元素即是中位数

1. 优先集队列

# 二分查找

平均速度：log2

问题，重复值的处理，定位一个值，然后向左/右，依次查找，直到找到不等于\<查找值\>的那个

值。所以，比较适合重复值少的情况。

3种大的结构，每个结构也可能有不同的算法。另外，开发某一功能，也不一定就非得用一种结构。也可以几种结构混合使用。因为每种结构都有缺点和缺点，没有完美的算法。具体还是得看项目需求。

# 线性查找

就是正常的，从容器中依次顺序遍历每个值，然后对比。这种是日常写代码中使用最多的，因为简单，适合性强，什么数据结构都可以用这种方法，缺点 可能就是无序的数据结构查找没有2分查找快些

算术表达式\-后缀

# 对一种算法的衡量

1. 时间复杂度
2. 空间复杂度

一种算法的好坏有很多种衡量因素，这里主要就讲两种，如上~

实际可以更精简的回答：任何算法就是为了提高速度，只要时间复杂度能提上去，大多会牺牲空间复杂度。

如：

1. 有些内存数据可以释放，但是防止此数据还会被访问，那就不释放...这就是缓存原理
2. 一条记录按说存在一个地方\(表\)，但是为了加快速度，该记录可能还会被存在在其它特定位置\(索引\)

# 递归算法

> 也叫，数学归纳法。重复一步的操作，循环执行，直到设置一个终止的条件\(否则死循环\)

跟代码执行栈，有点像，一个函数准备开始执行，就把该函数相关变量、常量压入栈中。如果函数在执行过程中，还调用了其它函数，就暂停该函数，将新函数再压入栈中执行。

斐波那契数列 ：当前数=前两个数之和

三角数：N位置的数=N位置\-1的数\+N

阶乘：1 \* 2 \* 3 \* 4 \* 5 .... \* N

汉诺：将几个递归大小的方块，从A柱上移到C柱上，中间借用一个空柱子

字母的全排列：把一个单词拆分成单个字母，计算出全排列

> 以上几个数学题都有那么点递归的意思，但哪个程序员蛋疼计算这些鸟东西，看看下面的实际应用：

1. 树的递归遍历\(前、中、后序\)
2. 归并排序
3. 递归二分查找

所以，递归这种算法更多的是以代码工具类使用

效率：比正常代码要慢

优点：几行代码搞定，略简单，取代循环

缺点：比正常代理效率低，占内存，因为栈不能轻易释放

# 大数据处理总结

一般都是数据较大~内存较小，一次把所有外部数据装进内存是不可能的。所以，先调用外部\-部分存储，分而之治，打散成若干小文件，之后或者HASH 统计 或者归并排序，再求结果

以TOP K（取出10W个IP中，次数最多的前10条） 为例

\(1\)先将计算出内存能最多读取多少条记录，比如1W条，那么，10000/10=10，那就准备分成10个文件。同时取模的数字为：10.

\(2\)先从大文件中，读取前1W条数据到内存，与模进行求余，将这1W条数据分散到10个文件中。

\(3\)大文件被打散成10个HASH 文件，相同的IP在同一个文件中，接着就是统计，每个IP出现的次数了，这里

1\)可以再把10个文件进行排序操作，再进行归并操作，再统计次数。然后找出前10个

2\)申请一块内存用于HASH，先取出一个文件，拿第一条，以IP为KEY，在HASH里查找，如果没

有，就把当前IP做为KEY，VALUE=1，存进去。如果有，把值\+1。这样，HASH里就存了无序

的IP出现次数，如果再排序统计归并，就和上面一样了，所以，我们分析，其实只要前10就

够，根本不需要排序，于是，从HASH里取出10条记录，排序后，放入堆中，接着再依次从这

10个文件中读取相应的数据，只要大于堆里的10条数据，就更新。

# 总结

通篇看完，肯定是收获比较大的，对编程思维、软件开发者的理解、对软硬件的更深层次理解，往大了说：对计算机软件/硬件体系的理解都更深。

> 有那么点突然开窍的感觉呢

所以，文章开头也说，这东西是基础中的基础，说它影响着现在全人类的进步也不为过，因为AI、大数据里还有更多的算法，虽然文章都是基础的算法，但这两个体系差不多。这也就引出，为啥大公司面试揪着这鬼不放的原因了

从1946年冯诺依曼发明计算机\(其实图灵更早发明\)，70多年左右，计算机发展的已经非常完善了，各种硬件性能的优化，工业级开源软件的诞生，对于现在普通程序员基本上碰不到这些数据结构与算法。尤其，做互联网开发的，跟硬件没关系，跟大数据、AI也没有关系，最多就是个CURD，且不在大公司工作的，这东西学了，其实用处不大..

就拿PHP举个例子吧：

> 非PHP程序员都鄙视这门语言，尤其搞JAVA的，当然，C语言鄙视一切...

我就觉得这门语言真是把上面的话总结并实践发挥到了极致，如：

静态型语言/编译型语言：缺点，指针、变量强类型、垃圾回收、内存不好管理

在PHP这儿全都解决了

而像他们的优点：大数据的算法

PHP通过了DBMS解决了....

> 另外，还有一些比较LOW的程序，说什么：万物皆协程，吹虚GO有多好，但我就想问：一个进程开100个协程和直接开100个进程，哪个快？不要总盯着一门语言拿优点去对比别的语言的缺点，真正的高手不会局限于某一门语言，而具体应用场景使用具体的语言做开发.

这就是讽刺的，大部分公司程序员日常写代码，也就是自行车级别，但面试让你造火箭.....

各公司非PHP程序员各种鄙视 PHP，但背地里喊着 招PHPER好难，JVM好难搞...

虽然，本人也挺抵触上面的事情，但没办法，还是得看，还是得学，为了更多的money~

索引

http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html

http://blog.csdn.net/v\_JULY\_v/article/details/6530142

http://www.cnblogs.com/xuqiang/archive/2011/05/16/2047001.html

