

# 概览

一堆数字，散落在一颗树型结构上，最顶层就是树的根，也叫根节点，仅一个。下面连接着一堆树枝，然后是叶子，叶子下面还可以继续连接树枝，树枝再连接叶子，一个循环。而数字就保存在这棵树的根、叶子上面。而数字是有一定算法才落在这颗树上的。

一个节点下面，可以有1个叶子，也可以有2个，甚至N个，这就形成了不同的树结构：

1. 二叉树
2. 2\-3\-4叉树

> 具体还是看使用场景，也没有完美的树

名词术语解释

|名词     |说明                                                                |备注                                      |
|---------|--------------------------------------------------------------------|------------------------------------------|
|根节点   |树的第一个元素，且只有一个                                          |算是入口节点，像CURD、遍历都得先找这个节点|
|节点     |树中的一个元素，并保存着关键值及自定义的数组值，使用者CURD操作的实体|                                          |
|叶子节点 |跟节点差不多，只是它下面不再有任何节点了，有点最终节点的意思        |                                          |
|子节点   |插入元素时，根据关键值，挂在某个节点X下面，该节点就是X的子节点      |                                          |
|父节点   |插入元素时，根据关键值，挂在某个节点X下面，X                        |                                          |
|叔父节点 |跟父节点同层级、同祖父                                              |红黑树中使用                              |
|层级/深度|最终成型的树肯定是一层一层的                                        |时间复杂度、平衡树等都要用这个值          |
|子树     |某个节点下的整棵树                                                  |平衡树会用                                |
|路径     |某个节点到某个节点经常的路线                                        |带权二权树会用到                          |
|关键字   |根据一个关键字，来组织树的结构。如：数字，小的靠左，大的右靠        |                                          |
|数据     |一个节点的核心是关键值，但还可以存其它做生意的东西，比如：一条记录  |                                          |

# 根据树的叶子散落情况，分类

1. 满二叉树：一颗辅开后，就是一个‘三角型’，即：所有节点都是有左右节点，左侧跟右侧完全相等\(超喜欢这种情况，但只是理想主义...\)
2. 完全二叉树：1.假设树的深度为K，K\-1层及以上，是满二叉树状态 2.K层所有的节点均是靠左侧
3. 非完全二叉树：上面2个条件任意一条不满足即是。

# 二叉树/二叉搜索树

> BST:binary search tree

数字与树的映射关系：当前叶节点保存的数字的左边的值小于当前节点值，右边是大于当前节点值。

数字正常的以线性结构存数组\(有序\)里或简单的有序链表里不好么？代码简单、计算简单，为毛整出个二叉树这个鬼？

答：有序数组它的每次移动太耗性能了。有序链表无法快速定位到一个元素值，必须得顺序全遍历。数组这种太扯了，而二叉树算是对链表的优化，还是链表的有序结构，但是每个节点之间的连接关系做出改变，不用全遍历了。

最好情况：如果是平衡的二叉树，O\(log2n\)

最差情况：二叉树，成直线状态，O\(n\)

影响值：树尽量平衡，'深度'，尽量低，因为度决定了时间复杂度。如何影响平衡的条件太多了，如：重复值过多、插入的顺序、数的散列程序等等。

优点：查找一些值时，综合效率最优。

缺点：

1. 平衡性，比如只有左节点那就变成了线性结构了。
2. 重复值，因为只能2个节点，重复值不好处理。
3. 遍历性，这个要比数组 链表略复杂一些。

适合场景：参考平衡二叉树吧，因为这东西拿来当\<树结构\>的教学入门可以，但实际使用中，缺点太多。

# 层级计算

深度优先：从根节点开始，往最深的一边找，然后回来，再换另一边（递归）

广度优先：从根节点开始，然后遍历第二层、第三层、循环。（队列）

> 强迫症的同学会觉得：就一层一层的遍历多好，非得绕来绕去的用深度优先算法...还得使用递归...

优缺点：

广度优先：他使用的是队列，得一次保存整层的节点，占用空间大，但是没有回溯操作，略快些。

深度优先：它使用的是递归，不用保存整层的节点，占用空间小些，但是有回溯操作，略慢些

从方向/角度看：

1. 广度优先 给每层打上层号是正向的~也就是 1\(根节点\) 2 3 4 5 ...
2. 深度优先是返过来的：10\(根节点\) 9 8 7 ... 1

深度优先：给每个节点标识层级（降序），同时还可以票房：计算左/右子树高度的

广度优先：给每个节点标识层级（升序）

# 最小值

从根节点开始，一直向左，找到最左的那个节点，就是最小值

# 最大值

从根节点开始，一直向右，找到最左的那个节点，就是最小值

# 相邻关键字计算

# 树结构的遍历方法

> 数组和链表正常依次向下/向上找值，就能实现全遍历，但树不是线性结构，从外形上看它有点像是个三角形\(平衡且叶节点都是满的前提\)，它的遍历并不是只有升降/降升，还有就是：它是有层级的概念的，还得支持层级的遍历。所以，它的遍历得从2个角度看：从形状上看，它可以从3个不同的角度开始遍历，从上下看，它有个层级遍历。

**先序：**

1. 一个节点，默认为根节点，直接弹出
2. 判断该节点是否有左节点，如果没有，开始找右节点
3. 判断该节点是否有左节点，如果有，找到左节点，并弹出左节点，继续寻找左左节点
4. 直到左节点均找完后，开始再找右节点，重复上面步骤
5. 直到节点

**中序：**

1. 一个节点，默认为根节点，先暂存该值
2. 判断该节点是否有左节点，如果没有，即弹出该节点
3. 判断该节点是否有左节点，如果有，缓存该左节点，继续左左节点
4. 假设当前左左节点没有左左左节点了，那么弹出该左左节点
5. 弹出左左节点的父节点\(左节点\)
6. 判断该节点是否有右节点，如果有，继续重复上面流程
7. 直到结束

**后序：**

跟中序差不多，也是先缓存根节点，然后先找节节点，但是，左节点找完后，并不着急弹出根节点，而是再找右节点，直到右节点都找完再弹出根节点

先序：根 左 右

中序：左 根 右

后序：左 右 根

> 顺序记不住的话，口诀：根先 根中 根后

层次：就是按照层级依次遍历

另外一个角度看，也是面试被问较多的，给定一个线性数据结构，恢复树：

先序： 第一个节点肯定是 根

中序：第一个节点肯定是最左侧的，也就是最小的节点

后序：第一个节点肯定是最右侧的，也就是最大的节点

这东西有啥用？

1. 先序：计算表达式，前缀
2. 中序：其实是排序\(升序\)。
3. 后序：计算表达式，后缀
4. 持久化到硬盘中，启动时，根据存储的顺序将树结构恢复到内存中

> 目前看，除了第2条确实我用过，其余3条没看出具体有啥用...

# 删除操作

1. 只有一个元素，删除即是清空
2. 左侧有一个值右侧空 或 返过来
3. 左右侧都有值，从右侧找出最小元素，提升到删除节点的位置

# 数组实现树

链表的组织方式，优点是：有删除操作时不用移动

缺点是：要每次跟内存申请与删除

数组的方式：

第一个元素值即为头，之后两上元素是左右节点，如果节点为空，数据的元素值也为空且有占位符

缺点：如果允许删除操作，那么移动的代价有点大

优点：一次申请固定长度的内存不用反复申请

> ps:感觉数组这实现树这种情况，只在特殊情况下有点用：不允许删除操作，实际使用场景意义不大

# 用数组表示树

> 上面的方法大多是基于链表结构，数组其实也可以表示树

按照深度层级依次存，根节点在最前面，两边如果为空的节点，放空值。

优点：查找简单，代码复杂度低，连续的内存空间，有一定性能提升

缺点：

1. 最深的那一层，决定了要放多少级，空的全得用\<空\>值补齐，非常浪费空间。
    如果，非平衡二叉树，且一边非常重，那这空间浪费的就是X2了。
2. 添加/删除 要移动整个数组

> 如果不允许删除操作，这种方式倒也可以试试，不过感觉有点鸡肋

# 重复值问题

这种情况，感觉在树里有点无奈。

1. 禁止插入重复值
2. 挂载，一个节点挂下再挂一个节点

两种方法其实都不完美，第1种基本上不可能，产品就先把你干死了，第二种肯定要牺牲掉性能，感觉重复值这种情况并不适合树结构...

# 树的节点旋转

旋转的初衷：把树变的更加平衡

旋转的结果：把层级变低

> 以前两条的前提是：树的关键字的顺序不能改变（树的左节点小于父节点，树的右节点大于父节点）

1. 左旋转：将该节点向左移动，同时计算新的位置
2. 右旋转：将该节点向左移动，同时计算新的位置

旋转的过程

> 以哪个节点做为支点\(轴\)，这个也没绝对的标准，我的实现是：以中间的那个做为支点

1. 先找到要旋转的3个节点\(也可以是2个\)
2. 从这3个节点中，找到哪个是要被移动的，即：最上面的那个节点，顶节点
3. 如果是右移，那就是顶节点下面的左节点，否则，顶节点的右节点，确定了 次节点
4. 将顶节点向左|右落下，然后挂到次节点下
5. \-\-\-\-\-\-以上4步骤完成后，其实3个节点的旋转已经完成，下面是收尾，即把新的3个节点重新合并到原树中
6. 原顶节点落下后，要把父指针指向次节点，次节点的父指针改成原顶节点的父节点
7. 原顶节点的父节点的左|右子节点指针，指向次节点
8. 如果旋转后，次节点变成了根节点，同时更新成员变量：根节点指针

> 从上面看，其实，旋转过程中核心用到的节点数是2个\(顶节点和次节点\)，而不是3个

旋转操作事例：

![WX20211104-131400.png](image/WX20211104-131400.png)

![WX20210927-175852.png](image/WX20210927-175852.png)

> 复杂的情况

![WX20211104-133047.png](image/WX20211104-133047.png)

经过一次旋转，将原本3级层变成了2层级，但这是简单的，因为要么就是左左，要么就是右右，实际场景会有\<折边型\>的情况，得旋转2次才能行

![WX20211104-131830.png](image/WX20211104-131830.png)

![WX20210927-180003.png](image/WX20210927-180003.png)

> 感觉这东西挺神奇吧...

# 平衡树\-高度平衡树 AVL

当一棵二叉树：出现倾斜时，如：添加|删除时，会做平衡算法，使树平衡。（深度降低）保证在搜索的时候，速度是最快的。

平衡因子\(公式\)：

> 任意节点：左子树的深度\-右子树的深度 \<= 绝对值\(1\)

对比红黑树感觉这限定规则好简单...，往往越简单越复杂...

当侧差值，找出 差值=2 的情况，其树的形状，如下：

LL:左左型，左2右0，右旋转一次

RR:右右型，左0右2，左旋转一次

LR:左右型，左2但第三层是挂在第二层的右边，左旋转一次和右旋转一次

RL:右左型，右2但第三层是挂在第二层的左边，左旋转一次和左旋转一次

计算过程就是：

1. 从新插入的节点或刚刚删除的节点出发，向上遍历，确定每个节点的左侧/右侧深度
2. 计算出每个节点的左右深度，找出最小不平衡树的那个节点
3. 根据此节点，再根据上面的4种情况，做出旋转

复杂度分析 ：

1. 每次插入|删除，需要计算每个节点的左子树高度与右子树的高度
2. 每次插入|删除，可能会发生旋转

# 平衡树\-红黑树 RBT

> 这里的红黑也可以是黄蓝或是深浅色，没特殊的限定，只是单纯的给节点加上一个附加的属性值，以做区别

它的限定条件：

1. 根节点是黑色
2. 每个节点是黑色或红色\(感觉废话,既然叫红黑树，肯定每个节点都得颜色啊\)
3. 如果一个节点是红色，那么他的两个子节点都得是黑色\(父结点与子结点不能同为红色and红色节点被黑色隔开\)
4. 每个叶子节点或空节点，都是黑色\(这里不是指普通的叶子节点，是特殊的\)
5. 从一个节点到任意叶子节点或空节点：经过的路径，黑色节点都是一样的。

> 这里多个概念：叶子节点/空节点，原本认知的叶子节点，又被多加了一层空叶子节点，它是用来做判断是否违规时候用，其实也可以不用。

从规则看，树中一半以上均是黑色，因为红色的限定条件本就多，再算上给多加了一层黑色的空叶子节点的概念

新插入的节点定义为：红色\(也可以是黑色，但违规的发生的概率要高\)

当插入一个新的节点后，开始检查，如违反了上述任意一条，就要开始修正操作：

1. 左旋转：将该节点向左移动，如果有右节点将右节点提升至原节点位置
2. 右旋转：将该节点向左移动，如果有右节点将右节点提升至原节点位置
3. 节点变色：红变黑 黑变红

插入时判断是否违规的几种情况：

|父节点|叔父节点|类型|操作                                                |\-\-|
|------|--------|----|----------------------------------------------------|----|
|黑色  |无      |\-  |\-                                                  |\-  |
|红色  |红色    |\-  |父叔均变黑色，祖父变红。祖父变成当前节点，递归此操作|\-  |
|红色  |黑色    |左左|右旋\+变色                                          |\-  |
|红色  |黑色    |右右|左旋\+变色                                          |\-  |
|红色  |黑色    |左右|左旋\+右旋\+变色                                    |\-  |
|红色  |黑色    |右左|右旋\+左旋\+变色                                    |\-  |

分析：

1. 父节点就一个，且父级没有其它叔父节点，这种最简单，完全符合条件
2. 其余的情况第一个条件就是父节点为红色，这直接就违背了第2条，剩下就是看叔父的颜色了
    1. 红色：父与叔父均是红色，直接递归操作就行，也算是略简单的
    2. 黑色：这种是最复杂的，

另外一个角度看，如果把所有红色节点去掉，再合并一下树，看看...

它其实在旋转上跟高度平衡树的算法是一样一样的，不同的是，高度平衡树得每次计算根及子树的高度值，而红黑树是计算父/叔父的颜色。 另外，当规则破坏后，它除了旋转会多了一步变色步骤。

# 两种平衡树\-对比

红黑树最大差：一倍

平衡树最大差：1

所以，平衡树对整体平衡度要求高于红黑树，导致它可能会大量的执行平衡操作。

平衡树：删除添加操作较少，适合

红黑树：对整棵树的平衡度要求没那么高，适合

# 2\-3\-4树

> 也叫：多路平衡二叉树
> 
> 
> 数值还是有序的存放：跟BST一样，左值肯定小于右值，依次按照大小顺序存于各节点中

|名词  |解释                               |
|------|-----------------------------------|
|节点  |正常往树上挂载的一个节点\(树枝\)   |
|节点值|一个节点里可以保存的值，可以有N个  |
|2\-3  |一个节点可以保存1个值或2个值或3个值|
|4     |一个节点最多可以有4个子节点        |
|裂变  |当一个节点内有4个值时就产生裂变    |

> 注：这里千万别把节点跟节点值弄混了，我特意画在表格里了。

限定规则：

|节点数|子节点数|
|------|--------|
|1     |2 或 空 |
|2     |3 或 空 |
|3     |4 或 空 |

> 每个节点下面必须得有\+1个子节点，或者该节点为空

一但上面规则被破坏，就得触发裂变

> 感觉跟平衡二叉树差不多呢，也是一但触发某些条件即立刻做出树调整

它的算法及裂变过程：

1. 插入一个值时，跟二叉树差不多，还是正常比较大小，然后决定放在哪个位置

> 区别：234树一个节点可能多个值，值的保存可能是一个数组，就得线性查找

1. 确定了位置后
2. 判断这个节点的值个数，是否\>=4 ，如果条件成立，触发裂变
3. 从当前节点的4个值中，取整 n/2\(最左侧开始，找出第2个值\)，然后弹出到上一层
4. 重复步骤上术步骤即可。
5. 最后将要插入的节点挂 到树上

> 裂变≈红黑树平衡调≈平衡树的旋转

1. 从裂变的角度看，它其实也是一棵平衡树~
2. 再从它的3个限定规则看，它是一颗满树

与二叉树的区别

1. 单节点可以存放多个值
2. 它的平衡算法有点本质区别，另外两种是旋转，而它是由下向上弹出
3. 二叉树基本上一个链表结构就够了，而它因为有多个值，保存的容器可能得用数组
4. 正常为一个节点最多保存两个指针，3个节点就是6个，而它一个节点中的3个值，最多保存4个
5. 其它树都是从上下往下长，它是从下往上长

有趣的是，2\-3\-4树展开后，是可以直接转化成红黑树的：

一个2\-3\-4树对应\-》多个红黑树

一个红黑树\-》对应一个2\-3\-4树

因为它一个节点可以保存2\-3个数字，这样，对比二叉树，它的深度要低，大概比二叉树小1倍

二叉树：log 2 n

2\-3\-4：log 4 n

查找的效率，平均看差不多，虽然会增加一个节点内的链式搜索，但因为元素少，但这也只是个常数，并不影响平均值

缺点：浪费空间

总结 ：各种文章书籍没咋标注，我自己也太理解透，感觉这个鬼东西，没啥实际用处... 反倒像是教学DEMO...

# 2-3树

> 跟2-3-4树有点像，区别：

1. 节点的值数量到3就开始了分裂，少了一上节点值数量
2. 它是先插入值再分裂，而2\-3\-4树是先分裂再插入值
3. 因为少保存了一个节点值，它的尝试要比2\-3\-4树略主同一些

# 磁盘与内存的读写

内存肯定是磁盘快的，因为：

1. 内存是直接寻址，大概1微秒
2. 硬盘得通过磁头寻址，大概10毫秒\(但真正的IO是毫秒级，只是寻址慢 \)

> 相差了大概10000倍\(1毫秒≈1000毫秒 \* 10\)，不过SSD的出现还是提升 了不少的

硬盘的一次IO最小单位是：block,它的大小由OS决定，肯定是2的N次方

> OS一次硬盘 的读取是一页，≈N个block

> 这东西跟树有啥关系 ？

理想状态下，当然是我们的整棵树都能装进内存中，然后，用内存计算。但有些情况 ，是不行的，如下：

1. 数据库，本就是装数据的地方，肯定大，就算OS上所有进程都让路给数据库，但也不可能把所有数据全加到内存中
2. 假设每个用户都要用到一颗树，当前有上万个用户，因为每个用户的树都不同

所以，当整棵树无法全放到内存中计算时，就得考虑要借用硬盘 来保存了。但已知硬盘 的IO速度 要比内存慢 10000倍，所以优化硬盘 的IO就是核心了。

先看一个词 ：顺序存储

一条记录，根据 一个关键值 \(索引值\)，如：ID 或 NAME ，顺序存储在硬盘 上

假设：一个block的大小是1024bytes,一条记录的大小也是1024bytes,OS一次硬盘IO是1024byte

那么 ，100条记录就需要100个block存储

查找 ：

> 已知1:单条记录的长度，块大小，可以计算出一个块存多少条记录
> 
> 
> 已知2:一共有多少条记录，能计算出有多少个块
> 
> 
> 根据已上两点，可以使用二分查找，硬盘 IO次数是log 2n

添加/删除 ：这个就是灾难 级别了，因为是按照顺序存，一但顺序发生改变，要移动所有 block 的记录

另外：某信集合，如果只是按照一个索引来IO还好，如果有多个呢...

如果使用普通 二叉树呢？查找 跟上面差不多，添加删除略好点，但是取地值 时没有顺序存储 的快

使用B\-tree

> b\-tree \+ 顺序存储 组合

每一个块中除了关键字\+数据，还多了指针，虽然占了点空间，但是每了个节点里的关键值变多了，减少了IO次数

# B树

> 也是多路平衡二叉树

阶：树中某节点最大的子节点数即为阶数，如：

> 2\-3 树:最多只有3个子节点，M=3
> 
> 
> 2\-3\-4树:最多有4个子节点,M=4

> 阶数=M，

即：M阶的树，每个节点包含的最多的关键字个数 ：m\-1

根节点，如果是终端节点那么可以为空，否则，必须得包含\<=2个子节点

普通节点\(非根节点、非叶子节点\)至少要有\(m/2\)个节点

所有叶子节点都在同一层上

> 从上面分析看，3个条件都是为了保证树是平衡的，每个节点都得有意义。尽量让树保持满树状态

从网上扒了张图，懒得画了：

![20160202204827368.jpg](image/20160202204827368.jpg)

1. 图中的M=3，第二层和第3层，都有3个子节点，有点类似2\-3树，一个节点里最多包含2个关键值，最大可以有3个子节点
2. 蓝色的P：指针，指向子节点的地址 （硬盘地址）
3. 一个硬盘 block就是一个节点

查找 没问题，添加删除勉强能接受

缺点：范围性查找，如：年龄大于10的，IO次数还是很高

另外，如果DATA过大，会挤压一个block的空间，最差结果可能一个节点只能保存一个子节点，又恢复成二叉树了

继续优化

1. 如果每个节点中的data 不保存真实的数据，而只是保存一个block索引号，那么一个块中可装的关键值就会非常 多，树的深度会降下来，查找会变化
2. 再单独的把所有data 按照顺序存储，那么范围性搜索慢的情况也跟着解决了
    或者说，这是：顺序存储\+B\-TRE索引的组合方式
    b\-tree 减少了磁盘的IO次数，顺序存储解决了范围搜索

注：如果线性数据顺序存储，还是会有移动整所有数据的情况，，这里不要用线性数组，用链表顺序增加删除

删除操作：索引肯定得重新调整位置 ，但是DATA的文件存储，只需要找到那条记录，打个删除标记就行了\(回头统一真删除，或者干脆就把新记录覆盖到这条记录上\)

插件操作：索引肯定得重新调整位置 ，但是DATA的文件存储，直接到文件尾部，插入即可

缺点：搜索数据，至少要进行二次操作，第一次是走索引，假设最好的情况第一次即搜索命中，但是要获取真实的数据记录，还得再根据索引值，再去硬盘中取一次。

另外，顺序存储还有个问题，多索引咋办？用b\-tree 可以建立其它类型的索引，但是最终DATA存文件的格式是不能变，范围查找肯定还是慢，但没太好办法

# B+Tree

> 算是对B\-Tree的升级，所以 才有一个加号

普通节点\(非叶子节点\)不存数据

数据只存储于叶子节点下

分析：整个数据落在硬盘后，前部分都是索引\(关键字、指针\)信息，剩下的大部分都是真数据，而这些数据落到叶子节点上，以中序遍历的角度看，就等于是顺序存储了，但得把叶子节点再加上个指针横向完全链接起来

# Trie/前缀树/字典树

操作字符串的一种算法~

1. 给定若干单词\(字符串\)，构建树
2. 个节点只有一个字母
3. 把单词拆成一个一个的字母，然后插入到树中即可

> 这是个多叉树

用途：

1. 搜索框里的模糊匹配，如：输入go 提示出：google golang 等

> 换种方式，也可以直接到MYSQL中用sql模糊查找，也可以从数组里逐一遍历，但字典树明显效率更高一点

1. 词频统计，查找词典里的某个单词（就是查找一个集合中的数字串）
2. 统计词典中单词的前缀情况\(感觉鸡肋\)

优点：

1. 比数组/链表/hashmap 性能要高一点
2. 比数组/链表/hashmap 更节省空间

缺点：

1. 复杂度略高
2. 得先构建树

> 个人觉得，有点鸡肋，用日常语言自带的数组更简单。它优化的只是：字符串的比较

既然有前缀，当然也可以反过来，做后缀树，但感觉没啥实际场景。

# hash\-tree

> 主要： 用于签名验证吧

一个大文件，被打散成10个小文件，10个小文件用hash函数加密码得到10个hash值，然后依次合并hash值，递归，继续合并，直到最后只剩下一个hash值：根hash

根hash就是一个最终签名

主要用处：感觉分布式存储用的更多，因为一个大文件，可以被打散成N个小文件，散落到任意节点~只要有根节点的hash值就可以做校验

# 外部存储\-排序

排序操作，可以在内存中计算，那么常规的排序算法都可以用

但，有些时候，因为数据量过大，内存不够，就得借用硬盘来做外部排序

核心思想：归并排序

假设，当前内存只够1000条数据 ，而此时的总数量为10000

1. 按照顺序，每次读取1000条，然后排序，将1000条有序的数据存于某个特定文件中，也可以存于某个大文件中
2. 这一轮操作后，10000条记录被分成10个段，每个段都是有序了，也就是：10000条记录局部有序
3. 第一段中读取500，再从第二段中读取500条，然后排序，存于一个文件中
4. 第一段中读取剩下的500条，再从第二段中读取剩的500条，然后排序，存于一个文件中
5. 经常3和4步骤原本10段的数据被合并成了5段，不停的重复3 和4步骤，直到排序完成

多路归并排序

上面就是两个文件进行比对，硬盘IO有点高，如果此时，进行多路归并，比如把2个合并，改成3个一起合并，效率能略好一点

# Huffman编译压缩

> 树结构：并不一定局限于对数字的\<加快搜索\>操作，它也可以用做：表达式解析、编码压缩等。

假设有一个字符串： SUSIE SAYS IT IS EASY

1. 统计每个字符出现的次数，即：频数

|字符|出现次数|编码 |
|----|--------|-----|
|A   |2       |010  |
|E   |2       |1111 |
|I   |3       |110  |
|S   |6       |10   |
|T   |1       |0110 |
|U   |1       |01111|
|Y   |2       |1110 |
|空格|4       |00   |

> 这里其实还没有生成：编码，只是暂时先列出来

1. 排序，根据每个字符的出现次数
2. 将排序好的字符数组压入栈中\(栈顶是频数最小的\)，如下：

> 关于相等值的压入顺序可以忽略，并不影响

|字符|出现次数|代替编码|
|----|--------|--------|
|换行|1       |01110   |
|U   |1       |01111   |
|T   |1       |0110    |
|Y   |2       |1110    |
|E   |2       |1111    |
|A   |2       |01111   |
|I   |3       |110     |
|空格|4       |00      |
|S   |6       |10      |

> S出现次数最多在栈底，最少的在栈底

1. 结合栈，构建Huffman树
    1. 每次从栈中弹出两个节点
    2. 创建一个新的：树节点
    3. 将两个栈节点挂在新的树节点的两边
    4. 然后，将新节点重新压入到栈中
    5. 新节点重新压栈得有规则，也就是比对计算位置，也就是栈里的节点是有序的\(根据出现次数\)
    6. 栈节点的关键值是：出现次数，新节点是两个原节点的次数之和
2. 根据已构建的Huffman树，开始连线，生成每个字符的二进制编码\(表格中已提前生成\)
3. 根据编码表格，开始压缩字符串，如下：

> 10 01111 10 110 1111 00 10 010 1110 10 00 110 0110 00 110 10 00 1111 010 10 1110 01110
> 
> 
> 注：实际情况没有空格，只是便于理解才加上的空格

1. 解码，把给定的字符串，每一位，拿到构建的Huffman树，按照路径，0向左走，1向右走，只要碰到是一个字符，即输出，同时回到Huffman树根部，重新再执行此步骤。

此算法如何做到了压缩功能？

> 正常字符流，任何一个字符都占1个字节，即：8个二进制位，Huffman算法，把出现频率最高的字符，由8个位换成了2个位，实现了压缩。

核心算法：通过一个容器\(有序栈\)，构建一个树，通过树再构建一个字符替换编码，再通过树进行压缩/解压缩

优点：加速了传输的速度。

缺点：

1. 肯定得牺牲些CPU的计算时间，用于压缩和解压缩，但以目前的计算机体系，可以忽略。
2. 从算法上看，被压缩的文档，重复的值越多，它的算法肯定越好，反之，压缩的效果一般。

## 总结

树结构其实算是对 线性结构\(数组、链表\) 的优化，比较适合 读多写少且重复值少的情况，像给一个二维表中的某个字段做索引。

