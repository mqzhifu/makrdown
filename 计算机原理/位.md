# 概览

计算机是用电的，正负极，数据与模拟信号，最终只有：0 1，所以，计算机最根本的操作，如：执行一条指令，基本都是位操作

## 什么是位\(bit\)？

计算机最底层的肯定就是0和1，也叫机器数，二进制码，而由0和1表示出人类能看懂的东西，大概就是叫做位运算吧

## 进制

1. 2进制：加减乘除中，缝2进一，这个就是要讲的重点
2. 8进制：加减乘除中，缝8进一，用的不多
3. 10进制：加减乘除中，缝10进一，人类最习惯的进制方法，不过在计算机底层的领域使用不多
4. 16进制：加减乘除中，缝16进一，使用较多，主要是节省显示的计算

## 单位

bytes:字节，8个二进制位组成一个字节

kb:1024 \* 1\(bytes\)

mb:1024 \* 1\(kb\)

gb:1024 \* 1\(mb\)

tb:1024 \* 1\(gb\)

## 字节

> 为啥要有字节？

节其实就是把计算机最小处理单位再加一层，原本可能要计算80次，而用字节实际计算8次就够了。有点像是公式，就是套上几个系数或代数，方便计算。

> 为啥字节是8位？不是10位？6位？

我的理解是：6 8 10 都可以，重要的是取一个平衡值，性能最大化。估计曾经那帮牛逼的人们最最终计算出8可能是最优的，然后，各大厂商跟进，约定死了就是：8个bit，最终就一直延续下来了...

> 既然有了字节为毛还学位运算？

位运算的性能是最高的，且还可以学到算法，当然可能更大成分是为了装逼...

以下所有DEMO均以字节为单位，就不再复述了，也可以是字 或者双字单位，都无所谓

## 正数/负数

一个字节的第一位为1：即是负数

一个字节的第一位为9：即为正数

有符号数：同上

无符号数：一个字节的第一位就是有用的数据，不做符号位

分析：同样一个字节，有符号数有效位数就是7位，而无符号数是8位，所以，无符号数可表示的正数多一倍，但没有负数 ，有符号数虽然正数少了一位，但可以表示负数.

## 溢出

有符号数说：\-256\+1 = 1

## 原/反/补\-码

1. 原码：拿出一个字节的第一位当符号位
2. 反码：正数不变，负数第一位不变，其余位取反
3. 补码：正数不变，负数第一位不变，其余位取反，最后加1

举例，当前有值为\-1：

原码：10000001

反码：11111110

补码：11111111

> 明显，正数无所谓，负数的情况下，一个数会有3个不同的编码结果，那么问题就出在负数上~

因为首位是负数，计算起来跟正数就是不太一样，加减乘除都得考虑这一位符号位，人脑计算能记住这种情况，但是计算机如果每次计算还得去分析首位就有点浪费时间了。

根据去处法则 1 \- 1= 1\+（\-1）= 0 ，这样就不需要减法了. 于是就在负数上开始动脑筋了.

> 1 \- 1 = 1 \+ \(\-1\) = \[0000 0001\]原 \+ \[1000 0001\]原= \[0000 0001\]反 \+ \[1111 1110\]反 = \[1111 1111\]反 = \[1000 0000\]原 = \-0

先将两个数都转换成反码，然后相加，最后再进行一次反码操作.

这种操作都是对的，但是有个特殊：0，即：\-0，这就有问题了，于是又出现补码了

> 1\-1 = 1 \+ \(\-1\) = \[0000 0001\]原 \+ \[1000 0001\]原 = \[0000 0001\]补 \+ \[1111 1111\]补 = \[0000 0000\]补=\[0000 0000\]原

先将两个数都转换成补码，然后相加即可

结论：运算时，对负数做特殊处理，间接等于符号位也直接加到了计算过程中。

## 位运算

与运算

> 两个字节里的相同位置上的：二进制位做运算，如果都为1即为1，其余都为0

或运算

> 两个字节里的相同位置上的：二进制位做运算，只要其中一个出现1即为1，只有同时为0时才是0

异或运算

> 两个字节里的相同位置上的：二进制位做运算，相同即为0，不同则为1
> 
> 
> 实际应用：判断两个数是否相等

左移/乘法

> 一个数字向左移动一位，即是剩x2，左移2位即x4

右移/除法

> 一个数字向左移动一位，即是除2，右移2位即除4

取一个字节（无符号数）中的某一个位，比如：从1中取最后一位，即第8位

00000001，先把此数向左移到7位，10000000，再跟512做与操作，即：10000000 & 10000000 = 10000000，再向右移7位，00000001

从数字9中取第5位

00001001向左移动4位10010000,再跟512做与操作，即：10010000 & 10000000 = 10000000，再向右移7位，00000001

实际应用场景：

大写转小写：

a | 空格\(32\) = 97\(01100000\) | 00100000 = a

A | 空格\(32\) = 65\(01000001\) | 00100000 = a

原理其实也挺简单：大小写 之间的a\-A 差是32，32是2的整数倍，间接等于二进制的某一位，\<或\>运算，就是计算这一位数，如果已经为1了，即不操作，如果是0的，改成1，实际上是，间接给大写字母的ascii码值加了32

小写转大写：

a & 下划线\(32\) = 97\(01100001\) | 01011111 = a

A & 下划线\(32\) = 65\(01000001\) | 01011111 = a

原理是：小写的字节ascii码减32，关键位：第3位，也就是00100000=32，这个是反向的操作，只有这一位0，其余均是1

大写转小写，小写转大写，用异或

a ^ 空格\(32\) = 97\(01100000\) ^ 00100000 = 01

A ^ 空格\(32\) = 65\(01000001\) ^ 00100000 = a

判断两个数字是否相等：异或运算

不使用判断 if ，判断 ，如何判断两个数的大小

假设丙从此a=10 b=12

a\-b = \-2

